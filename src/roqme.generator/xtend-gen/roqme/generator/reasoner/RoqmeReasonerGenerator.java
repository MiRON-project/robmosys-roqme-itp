package roqme.generator.reasoner;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import java.util.ArrayList;
import java.util.List;
import org.apache.commons.math3.linear.EigenDecomposition;
import org.apache.commons.math3.linear.MatrixUtils;
import org.apache.commons.math3.linear.RealMatrix;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.eclipse.xtext.xbase.lib.StringExtensions;
import roqme.metamodel.datatypes.RoqmeModel;
import roqme.metamodel.datatypes.TimeValue;
import roqme.metamodel.kernel.BeliefVariable;
import roqme.metamodel.kernel.InfluenceEnum;
import roqme.metamodel.kernel.Observation;
import roqme.metamodel.kernel.SetEvidence;

@SuppressWarnings("all")
public class RoqmeReasonerGenerator extends AbstractGenerator {
  private final int DEFAULT_PROP_SURVIVAL_SEC = 300;
  
  private final double DEFAULT_PROP_REFERENCE = 0.5;
  
  private ArrayList<String> variableNames = new ArrayList<String>();
  
  private ArrayList<String> propertyNames = new ArrayList<String>();
  
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    boolean _equalsIgnoreCase = resource.getURI().fileExtension().equalsIgnoreCase("roqme");
    if (_equalsIgnoreCase) {
      Iterable<RoqmeModel> _filter = Iterables.<RoqmeModel>filter(IteratorExtensions.<EObject>toIterable(resource.getAllContents()), RoqmeModel.class);
      for (final RoqmeModel model : _filter) {
        {
          boolean _isNullOrEmpty = StringExtensions.isNullOrEmpty(model.getNamespace());
          if (_isNullOrEmpty) {
            final String[] splitStr = resource.getURI().lastSegment().split("\\.");
            model.setNamespace(splitStr[0]);
          }
          String _namespace = model.getNamespace();
          String _plus = (_namespace + ".duai");
          fsa.generateFile(_plus, this.generateDUAI(model));
          String _namespace_1 = model.getNamespace();
          String _plus_1 = (_namespace_1 + ".config");
          fsa.generateFile(_plus_1, this.generateConfig());
          String _namespace_2 = model.getNamespace();
          String _plus_2 = ("run_" + _namespace_2);
          String _plus_3 = (_plus_2 + ".sh");
          fsa.generateFile(_plus_3, this.generateScript(model.getNamespace()));
        }
      }
    }
  }
  
  public CharSequence generateScript(final String fileName) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("#!/bin/bash");
    _builder.newLine();
    _builder.append("# Starts the RoQME reasoner. Generated by the RoQME Modeling Tool");
    _builder.newLine();
    _builder.newLine();
    _builder.append("./roqme-reasoner ");
    _builder.append(fileName);
    _builder.append(".duai ");
    _builder.append(fileName);
    _builder.append(".config");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence generateConfig() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("# Configuration of the RoQME reasoner. Generated by the RoQME Modeling Tool");
    _builder.newLine();
    _builder.newLine();
    _builder.append("period.ms = 4000");
    _builder.newLine();
    _builder.append("inference.method = Filtering-VE");
    _builder.newLine();
    _builder.append("variables.names = ");
    {
      boolean _hasElements = false;
      for(final String variable : this.variableNames) {
        if (!_hasElements) {
          _hasElements = true;
        } else {
          _builder.appendImmediate(", ", "");
        }
        _builder.append(variable);
      }
    }
    _builder.newLineIfNotEmpty();
    _builder.append("variables.query = ");
    {
      boolean _hasElements_1 = false;
      for(final String prop : this.propertyNames) {
        if (!_hasElements_1) {
          _hasElements_1 = true;
        } else {
          _builder.appendImmediate(", ", "");
        }
        _builder.append(prop);
      }
    }
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence generateDUAI(final RoqmeModel model) {
    CharSequence _xblockexpression = null;
    {
      int index = 0;
      StringBuffer two_tbn = new StringBuffer();
      StringBuffer sensor = new StringBuffer();
      StringBuffer domains = new StringBuffer();
      StringBuffer factors = new StringBuffer();
      List<Double> prior = new ArrayList<Double>();
      List<Double> transition = new ArrayList<Double>();
      List<Double> obsProb = new ArrayList<Double>();
      Iterable<BeliefVariable> _filter = Iterables.<BeliefVariable>filter(model.getVariables(), BeliefVariable.class);
      for (final BeliefVariable beliefVar : _filter) {
        {
          this.propertyNames.add(beliefVar.getName());
          this.variableNames.add(beliefVar.getName());
          String _name = beliefVar.getName();
          String _plus = (_name + "_p");
          this.variableNames.add(_plus);
          this.calculatePropProb(
            beliefVar.getReference(), 
            this.getTimeInSec(beliefVar.getSurvival()), prior, transition);
          factors.append(this.probToString(prior));
          factors.append(this.probToString(transition));
          two_tbn.append(index);
          two_tbn.append(" ");
          domains.append("1");
          domains.append(" ");
          domains.append(index);
          domains.append("\n");
          index++;
          two_tbn.append(index);
          two_tbn.append(" ");
          domains.append("2");
          domains.append(" ");
          domains.append(index);
          domains.append(" ");
          domains.append((index - 1));
          domains.append("\n");
          index++;
        }
      }
      Iterable<SetEvidence> evList = null;
      final int nBeliefVar = this.variableNames.size();
      Iterable<Observation> _filter_1 = Iterables.<Observation>filter(model.getSentences(), Observation.class);
      for (final Observation obs : _filter_1) {
        {
          this.variableNames.add(obs.getName());
          sensor.append(index);
          sensor.append(" ");
          evList = Iterables.<SetEvidence>filter(obs.getActions(), SetEvidence.class);
          int _size = IterableExtensions.size(evList);
          int _plus = (_size + 1);
          domains.append(_plus);
          domains.append(" ");
          domains.append(index);
          for (final SetEvidence ev : evList) {
            {
              domains.append(" ");
              domains.append(this.variableNames.indexOf(ev.getTarget().getName()));
              obsProb.clear();
              InfluenceEnum _influence = ev.getInfluence();
              boolean _equals = Objects.equal(_influence, InfluenceEnum.REINFORCE);
              this.calculateObsProb(_equals, 
                ev.getStrength().getValue(), obsProb);
              factors.append(this.probToString(obsProb));
            }
          }
          domains.append("\n");
          index++;
        }
      }
      index = 0;
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("# Generated by the RoQME Modeling Tool");
      _builder.newLine();
      _builder.newLine();
      _builder.append("DBAYES");
      _builder.newLine();
      _builder.newLine();
      _builder.append("# Variables");
      _builder.newLine();
      int _size = this.variableNames.size();
      _builder.append(_size);
      _builder.newLineIfNotEmpty();
      {
        for(final String aux : this.variableNames) {
          _builder.append("2\t# id=");
          _builder.append(index);
          _builder.append(" name=");
          int _plusPlus = index++;
          String _get = this.variableNames.get(_plusPlus);
          _builder.append(_get);
          _builder.append(" domain={0,1}");
          _builder.newLineIfNotEmpty();
        }
      }
      _builder.newLine();
      _builder.append("# 2TBN");
      _builder.newLine();
      _builder.append(nBeliefVar);
      _builder.append(" ");
      String _string = two_tbn.toString();
      _builder.append(_string);
      _builder.newLineIfNotEmpty();
      _builder.newLine();
      _builder.append("# Sensors");
      _builder.newLine();
      int _size_1 = this.variableNames.size();
      int _minus = (_size_1 - nBeliefVar);
      _builder.append(_minus);
      _builder.append(" ");
      String _string_1 = sensor.toString();
      _builder.append(_string_1);
      _builder.newLineIfNotEmpty();
      _builder.newLine();
      _builder.append("# Domains");
      _builder.newLine();
      String _string_2 = domains.toString();
      _builder.append(_string_2);
      _builder.newLineIfNotEmpty();
      _builder.newLine();
      _builder.append("# Factors");
      _builder.newLine();
      String _string_3 = factors.toString();
      _builder.append(_string_3);
      _builder.newLineIfNotEmpty();
      _builder.newLine();
      _xblockexpression = _builder;
    }
    return _xblockexpression;
  }
  
  public boolean calculatePropProb(final double reference, final double survival_sec, final List<Double> prior, final List<Double> transition) {
    boolean _xblockexpression = false;
    {
      double _xifexpression = (double) 0;
      if (((reference >= 0) && (reference < 1))) {
        _xifexpression = reference;
      } else {
        double _xifexpression_1 = (double) 0;
        if ((reference == 1)) {
          _xifexpression_1 = 0.99;
        } else {
          _xifexpression_1 = this.DEFAULT_PROP_REFERENCE;
        }
        _xifexpression = _xifexpression_1;
      }
      final double refVal = _xifexpression;
      double _xifexpression_2 = (double) 0;
      if ((survival_sec > 0)) {
        _xifexpression_2 = survival_sec;
      } else {
        _xifexpression_2 = this.DEFAULT_PROP_SURVIVAL_SEC;
      }
      final double survivalVal = _xifexpression_2;
      EigenDecomposition eigen = null;
      try {
        final double lambda = (1 / survivalVal);
        final double mu = ((lambda * refVal) / (1 - refVal));
        RealMatrix _createRealMatrix = MatrixUtils.createRealMatrix(new double[][] { new double[] { (-lambda), lambda }, new double[] { mu, (-mu) } });
        EigenDecomposition _eigenDecomposition = new EigenDecomposition(_createRealMatrix);
        eigen = _eigenDecomposition;
      } catch (final Throwable _t) {
        if (_t instanceof Exception) {
          final Exception e = (Exception)_t;
          final double lambda_1 = (1 / this.DEFAULT_PROP_SURVIVAL_SEC);
          final double mu_1 = ((lambda_1 * this.DEFAULT_PROP_REFERENCE) / (1 - this.DEFAULT_PROP_REFERENCE));
          RealMatrix _createRealMatrix_1 = MatrixUtils.createRealMatrix(new double[][] { new double[] { (-lambda_1), lambda_1 }, new double[] { mu_1, (-mu_1) } });
          EigenDecomposition _eigenDecomposition_1 = new EigenDecomposition(_createRealMatrix_1);
          eigen = _eigenDecomposition_1;
        } else {
          throw Exceptions.sneakyThrow(_t);
        }
      }
      prior.clear();
      transition.clear();
      prior.add(Double.valueOf((1 - refVal)));
      prior.add(Double.valueOf(refVal));
      double[][] d = eigen.getD().getData();
      for (int i = 0; (i < d.length); i++) {
        d[i][i] = Math.exp(d[i][i]);
      }
      final RealMatrix matV_inv = MatrixUtils.inverse(eigen.getV());
      final RealMatrix matP = eigen.getV().multiply(MatrixUtils.createRealMatrix(d)).multiply(matV_inv);
      transition.add(Double.valueOf(matP.getEntry(1, 1)));
      transition.add(Double.valueOf(matP.getEntry(0, 1)));
      transition.add(Double.valueOf(matP.getEntry(1, 0)));
      _xblockexpression = transition.add(Double.valueOf(matP.getEntry(0, 0)));
    }
    return _xblockexpression;
  }
  
  public boolean calculateObsProb(final boolean reinforces, final int strength, final List<Double> probability) {
    boolean _xblockexpression = false;
    {
      double _xifexpression = (double) 0;
      if ((strength == 0)) {
        _xifexpression = 0.1;
      } else {
        double _xifexpression_1 = (double) 0;
        if ((strength == 1)) {
          _xifexpression_1 = 0.3;
        } else {
          double _xifexpression_2 = (double) 0;
          if ((strength == 2)) {
            _xifexpression_2 = 0.5;
          } else {
            double _xifexpression_3 = (double) 0;
            if ((strength == 3)) {
              _xifexpression_3 = 0.7;
            } else {
              double _xifexpression_4 = (double) 0;
              if ((strength == 4)) {
                _xifexpression_4 = 0.9;
              } else {
                _xifexpression_4 = 0.5;
              }
              _xifexpression_3 = _xifexpression_4;
            }
            _xifexpression_2 = _xifexpression_3;
          }
          _xifexpression_1 = _xifexpression_2;
        }
        _xifexpression = _xifexpression_1;
      }
      final double lr = _xifexpression;
      double _random = Math.random();
      double _multiply = (_random * 0.95);
      double aux = (_multiply + 0.025);
      probability.clear();
      boolean _xifexpression_5 = false;
      if (reinforces) {
        boolean _xblockexpression_1 = false;
        {
          probability.add(Double.valueOf((1 - (lr * aux))));
          probability.add(Double.valueOf((1 - aux)));
          probability.add(Double.valueOf((lr * aux)));
          _xblockexpression_1 = probability.add(Double.valueOf(aux));
        }
        _xifexpression_5 = _xblockexpression_1;
      } else {
        boolean _xblockexpression_2 = false;
        {
          probability.add(Double.valueOf((lr * aux)));
          probability.add(Double.valueOf(aux));
          probability.add(Double.valueOf((1 - (lr * aux))));
          _xblockexpression_2 = probability.add(Double.valueOf((1 - aux)));
        }
        _xifexpression_5 = _xblockexpression_2;
      }
      _xblockexpression = _xifexpression_5;
    }
    return _xblockexpression;
  }
  
  public double getTimeInSec(final TimeValue time) {
    double result = 0;
    if ((time != null)) {
      String _unit = time.getUnit();
      if (_unit != null) {
        switch (_unit) {
          case "milliseconds":
          case "millisecond":
            double _value = time.getValue();
            double _divide = (_value / 1000);
            result = _divide;
            break;
          case "seconds":
          case "second":
            result = time.getValue();
            break;
          case "minutes":
          case "minute":
            double _value_1 = time.getValue();
            double _multiply = (_value_1 * 60);
            result = _multiply;
            break;
          case "hours":
          case "hour":
            double _value_2 = time.getValue();
            double _multiply_1 = (_value_2 * 60);
            double _multiply_2 = (_multiply_1 * 60);
            result = _multiply_2;
            break;
          case "days":
          case "day":
            double _value_3 = time.getValue();
            double _multiply_3 = (_value_3 * 60);
            double _multiply_4 = (_multiply_3 * 60);
            double _multiply_5 = (_multiply_4 * 24);
            result = _multiply_5;
            break;
        }
      }
    }
    return result;
  }
  
  public String probToString(final List<Double> prob) {
    StringBuffer result = new StringBuffer();
    result.append(prob.size());
    result.append(" ");
    for (final Double p : prob) {
      {
        result.append(p);
        result.append(" ");
      }
    }
    return result.append("\n").toString();
  }
}
