/*
 * generated by Xtext 2.12.0
 */
package org.xtext.roqme.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.roqme.services.RoQMEGrammarAccess;
import roqme.metamodel.datatypes.ArrayValue;
import roqme.metamodel.datatypes.BooleanType;
import roqme.metamodel.datatypes.BooleanValue;
import roqme.metamodel.datatypes.ContainedDeclaration;
import roqme.metamodel.datatypes.DataTypeDefinition;
import roqme.metamodel.datatypes.DatatypesPackage;
import roqme.metamodel.datatypes.EnumLiteral;
import roqme.metamodel.datatypes.EnumType;
import roqme.metamodel.datatypes.EnumValue;
import roqme.metamodel.datatypes.EventType;
import roqme.metamodel.datatypes.EventValue;
import roqme.metamodel.datatypes.InbuiltDeclaration;
import roqme.metamodel.datatypes.LowerBound;
import roqme.metamodel.datatypes.NumericType;
import roqme.metamodel.datatypes.NumericValue;
import roqme.metamodel.datatypes.ReferencedDeclaration;
import roqme.metamodel.datatypes.RoqmeModel;
import roqme.metamodel.datatypes.TimeType;
import roqme.metamodel.datatypes.TimeValue;
import roqme.metamodel.datatypes.UnitMeasuredType;
import roqme.metamodel.datatypes.UnitMeasuredValue;
import roqme.metamodel.datatypes.UpperBound;
import roqme.metamodel.expressions.AddTerm;
import roqme.metamodel.expressions.AggregationFunction;
import roqme.metamodel.expressions.AndBooleanTerm;
import roqme.metamodel.expressions.AndEventTerm;
import roqme.metamodel.expressions.ArithFunction;
import roqme.metamodel.expressions.CollectionFunction;
import roqme.metamodel.expressions.ConditionalTerm;
import roqme.metamodel.expressions.ConstTerm;
import roqme.metamodel.expressions.ContextPattern;
import roqme.metamodel.expressions.DivTerm;
import roqme.metamodel.expressions.EqualTerm;
import roqme.metamodel.expressions.ExpressionsPackage;
import roqme.metamodel.expressions.FollowedByTerm;
import roqme.metamodel.expressions.GeneralExpression;
import roqme.metamodel.expressions.GreaterEqualTerm;
import roqme.metamodel.expressions.GreaterThanTerm;
import roqme.metamodel.expressions.LessEqualTerm;
import roqme.metamodel.expressions.LessThanTerm;
import roqme.metamodel.expressions.MultTerm;
import roqme.metamodel.expressions.NotBooleanTerm;
import roqme.metamodel.expressions.NotEqualTerm;
import roqme.metamodel.expressions.NotEventTerm;
import roqme.metamodel.expressions.OnceTerm;
import roqme.metamodel.expressions.OrBooleanTerm;
import roqme.metamodel.expressions.OrEventTerm;
import roqme.metamodel.expressions.OutputTransformation;
import roqme.metamodel.expressions.PatternFunction;
import roqme.metamodel.expressions.RangeTerm;
import roqme.metamodel.expressions.RepeatTerm;
import roqme.metamodel.expressions.ScheduleFunction;
import roqme.metamodel.expressions.SelfTerm;
import roqme.metamodel.expressions.SubTerm;
import roqme.metamodel.expressions.VarTerm;
import roqme.metamodel.expressions.WhileTerm;
import roqme.metamodel.kernel.BeliefVariable;
import roqme.metamodel.kernel.ClearEvidence;
import roqme.metamodel.kernel.DerivedContext;
import roqme.metamodel.kernel.GeneralPurposeVariable;
import roqme.metamodel.kernel.Import;
import roqme.metamodel.kernel.KernelPackage;
import roqme.metamodel.kernel.Observation;
import roqme.metamodel.kernel.PrimitiveContext;
import roqme.metamodel.kernel.Property;
import roqme.metamodel.kernel.ResumeTimer;
import roqme.metamodel.kernel.SetEvidence;
import roqme.metamodel.kernel.SetVariable;
import roqme.metamodel.kernel.StartTimer;
import roqme.metamodel.kernel.StopTimer;
import roqme.metamodel.kernel.Timer;

@SuppressWarnings("all")
public class RoQMESemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private RoQMEGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DatatypesPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DatatypesPackage.ARRAY_VALUE:
				if (rule == grammarAccess.getBooleanArrayRule()) {
					sequence_BooleanArray(context, (ArrayValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypedValueRule()
						|| rule == grammarAccess.getArrayValueRule()) {
					sequence_BooleanArray_EnumArray_NumericArray_Impl_TimeArray_UnitMeasuredArray_Impl(context, (ArrayValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEnumArrayRule()) {
					sequence_EnumArray(context, (ArrayValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNumericArray_ImplRule()) {
					sequence_NumericArray_Impl(context, (ArrayValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNumericArrayRule()) {
					sequence_NumericArray_Impl_TimeArray_UnitMeasuredArray_Impl(context, (ArrayValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTimeArrayRule()) {
					sequence_TimeArray(context, (ArrayValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnitMeasuredArrayRule()) {
					sequence_TimeArray_UnitMeasuredArray_Impl(context, (ArrayValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnitMeasuredArray_ImplRule()) {
					sequence_UnitMeasuredArray_Impl(context, (ArrayValue) semanticObject); 
					return; 
				}
				else break;
			case DatatypesPackage.BOOLEAN_TYPE:
				sequence_BooleanType(context, (BooleanType) semanticObject); 
				return; 
			case DatatypesPackage.BOOLEAN_VALUE:
				sequence_BooleanValue(context, (BooleanValue) semanticObject); 
				return; 
			case DatatypesPackage.CONTAINED_DECLARATION:
				sequence_ContainedDeclaration(context, (ContainedDeclaration) semanticObject); 
				return; 
			case DatatypesPackage.DATA_TYPE_DEFINITION:
				sequence_DataTypeDefinition(context, (DataTypeDefinition) semanticObject); 
				return; 
			case DatatypesPackage.ENUM_LITERAL:
				sequence_EnumLiteral(context, (EnumLiteral) semanticObject); 
				return; 
			case DatatypesPackage.ENUM_TYPE:
				sequence_EnumType(context, (EnumType) semanticObject); 
				return; 
			case DatatypesPackage.ENUM_VALUE:
				sequence_EnumValue(context, (EnumValue) semanticObject); 
				return; 
			case DatatypesPackage.EVENT_TYPE:
				sequence_EventType(context, (EventType) semanticObject); 
				return; 
			case DatatypesPackage.EVENT_VALUE:
				sequence_EventValue(context, (EventValue) semanticObject); 
				return; 
			case DatatypesPackage.INBUILT_DECLARATION:
				sequence_InbuiltDeclaration(context, (InbuiltDeclaration) semanticObject); 
				return; 
			case DatatypesPackage.LOWER_BOUND:
				sequence_LowerBound(context, (LowerBound) semanticObject); 
				return; 
			case DatatypesPackage.NUMERIC_TYPE:
				sequence_NumericType(context, (NumericType) semanticObject); 
				return; 
			case DatatypesPackage.NUMERIC_VALUE:
				sequence_NumericValue_Impl(context, (NumericValue) semanticObject); 
				return; 
			case DatatypesPackage.REFERENCED_DECLARATION:
				sequence_ReferencedDeclaration(context, (ReferencedDeclaration) semanticObject); 
				return; 
			case DatatypesPackage.ROQME_MODEL:
				sequence_RoqmeModel(context, (RoqmeModel) semanticObject); 
				return; 
			case DatatypesPackage.TIME_TYPE:
				sequence_TimeType(context, (TimeType) semanticObject); 
				return; 
			case DatatypesPackage.TIME_VALUE:
				sequence_TimeValue(context, (TimeValue) semanticObject); 
				return; 
			case DatatypesPackage.UNIT_MEASURED_TYPE:
				sequence_UnitMeasuredType(context, (UnitMeasuredType) semanticObject); 
				return; 
			case DatatypesPackage.UNIT_MEASURED_VALUE:
				sequence_UnitMeasuredValue_Impl(context, (UnitMeasuredValue) semanticObject); 
				return; 
			case DatatypesPackage.UPPER_BOUND:
				sequence_UpperBound(context, (UpperBound) semanticObject); 
				return; 
			}
		else if (epackage == ExpressionsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ExpressionsPackage.ADD_TERM:
				sequence_AdditionTerm(context, (AddTerm) semanticObject); 
				return; 
			case ExpressionsPackage.AGGREGATION_FUNCTION:
				sequence_AggregationFunction(context, (AggregationFunction) semanticObject); 
				return; 
			case ExpressionsPackage.AND_BOOLEAN_TERM:
				sequence_AndBooleanTerm(context, (AndBooleanTerm) semanticObject); 
				return; 
			case ExpressionsPackage.AND_EVENT_TERM:
				sequence_AndEventTerm(context, (AndEventTerm) semanticObject); 
				return; 
			case ExpressionsPackage.ARITH_FUNCTION:
				sequence_ArithFunction(context, (ArithFunction) semanticObject); 
				return; 
			case ExpressionsPackage.COLLECTION_FUNCTION:
				sequence_CollectionFunction(context, (CollectionFunction) semanticObject); 
				return; 
			case ExpressionsPackage.CONDITIONAL_TERM:
				sequence_ConditionalTerm(context, (ConditionalTerm) semanticObject); 
				return; 
			case ExpressionsPackage.CONST_TERM:
				sequence_ConstTerm(context, (ConstTerm) semanticObject); 
				return; 
			case ExpressionsPackage.CONTEXT_PATTERN:
				sequence_ContextPattern(context, (ContextPattern) semanticObject); 
				return; 
			case ExpressionsPackage.DIV_TERM:
				sequence_MultiplicationTerm(context, (DivTerm) semanticObject); 
				return; 
			case ExpressionsPackage.EQUAL_TERM:
				sequence_RelationalTerm(context, (EqualTerm) semanticObject); 
				return; 
			case ExpressionsPackage.FOLLOWED_BY_TERM:
				sequence_SequenceTerm(context, (FollowedByTerm) semanticObject); 
				return; 
			case ExpressionsPackage.GENERAL_EXPRESSION:
				sequence_GeneralExpression(context, (GeneralExpression) semanticObject); 
				return; 
			case ExpressionsPackage.GREATER_EQUAL_TERM:
				sequence_RelationalTerm(context, (GreaterEqualTerm) semanticObject); 
				return; 
			case ExpressionsPackage.GREATER_THAN_TERM:
				sequence_RelationalTerm(context, (GreaterThanTerm) semanticObject); 
				return; 
			case ExpressionsPackage.LESS_EQUAL_TERM:
				sequence_RelationalTerm(context, (LessEqualTerm) semanticObject); 
				return; 
			case ExpressionsPackage.LESS_THAN_TERM:
				sequence_RelationalTerm(context, (LessThanTerm) semanticObject); 
				return; 
			case ExpressionsPackage.MULT_TERM:
				sequence_MultiplicationTerm(context, (MultTerm) semanticObject); 
				return; 
			case ExpressionsPackage.NOT_BOOLEAN_TERM:
				sequence_NotBooleanTerm(context, (NotBooleanTerm) semanticObject); 
				return; 
			case ExpressionsPackage.NOT_EQUAL_TERM:
				sequence_RelationalTerm(context, (NotEqualTerm) semanticObject); 
				return; 
			case ExpressionsPackage.NOT_EVENT_TERM:
				sequence_NotEventTerm(context, (NotEventTerm) semanticObject); 
				return; 
			case ExpressionsPackage.ONCE_TERM:
				sequence_OnceTerm(context, (OnceTerm) semanticObject); 
				return; 
			case ExpressionsPackage.OR_BOOLEAN_TERM:
				sequence_OrBooleanTerm(context, (OrBooleanTerm) semanticObject); 
				return; 
			case ExpressionsPackage.OR_EVENT_TERM:
				sequence_OrEventTerm(context, (OrEventTerm) semanticObject); 
				return; 
			case ExpressionsPackage.OUTPUT_TRANSFORMATION:
				sequence_OutputTransformation(context, (OutputTransformation) semanticObject); 
				return; 
			case ExpressionsPackage.PATTERN_FUNCTION:
				sequence_PatternFunction(context, (PatternFunction) semanticObject); 
				return; 
			case ExpressionsPackage.RANGE_TERM:
				sequence_RepetionTerm(context, (RangeTerm) semanticObject); 
				return; 
			case ExpressionsPackage.REPEAT_TERM:
				sequence_RepetionTerm(context, (RepeatTerm) semanticObject); 
				return; 
			case ExpressionsPackage.SCHEDULE_FUNCTION:
				sequence_ScheduleFunction(context, (ScheduleFunction) semanticObject); 
				return; 
			case ExpressionsPackage.SELF_TERM:
				sequence_SelfTerm(context, (SelfTerm) semanticObject); 
				return; 
			case ExpressionsPackage.SUB_TERM:
				sequence_AdditionTerm(context, (SubTerm) semanticObject); 
				return; 
			case ExpressionsPackage.VAR_TERM:
				sequence_VarTerm(context, (VarTerm) semanticObject); 
				return; 
			case ExpressionsPackage.WHILE_TERM:
				sequence_WhileTerm(context, (WhileTerm) semanticObject); 
				return; 
			}
		else if (epackage == KernelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case KernelPackage.BELIEF_VARIABLE:
				sequence_BeliefVariableImpl(context, (BeliefVariable) semanticObject); 
				return; 
			case KernelPackage.CLEAR_EVIDENCE:
				sequence_ClearEvidence(context, (ClearEvidence) semanticObject); 
				return; 
			case KernelPackage.DERIVED_CONTEXT:
				sequence_DerivedContext(context, (DerivedContext) semanticObject); 
				return; 
			case KernelPackage.GENERAL_PURPOSE_VARIABLE:
				sequence_GeneralPurposeVariable(context, (GeneralPurposeVariable) semanticObject); 
				return; 
			case KernelPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case KernelPackage.OBSERVATION:
				sequence_Observation(context, (Observation) semanticObject); 
				return; 
			case KernelPackage.PARAMETER:
				sequence_Parameter(context, (roqme.metamodel.kernel.Parameter) semanticObject); 
				return; 
			case KernelPackage.PRIMITIVE_CONTEXT:
				sequence_PrimitiveContext(context, (PrimitiveContext) semanticObject); 
				return; 
			case KernelPackage.PROPERTY:
				sequence_Property(context, (Property) semanticObject); 
				return; 
			case KernelPackage.RESUME_TIMER:
				sequence_ResumeTimer(context, (ResumeTimer) semanticObject); 
				return; 
			case KernelPackage.SET_EVIDENCE:
				sequence_SetEvidence(context, (SetEvidence) semanticObject); 
				return; 
			case KernelPackage.SET_VARIABLE:
				sequence_SetVariable(context, (SetVariable) semanticObject); 
				return; 
			case KernelPackage.START_TIMER:
				sequence_StartTimer(context, (StartTimer) semanticObject); 
				return; 
			case KernelPackage.STOP_TIMER:
				sequence_StopTimer(context, (StopTimer) semanticObject); 
				return; 
			case KernelPackage.TIMER:
				sequence_Timer(context, (Timer) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Term returns AddTerm
	 *     WhileTerm returns AddTerm
	 *     WhileTerm.WhileTerm_1_0 returns AddTerm
	 *     RepetionTerm returns AddTerm
	 *     RepetionTerm.RepeatTerm_1_0_0 returns AddTerm
	 *     RepetionTerm.RangeTerm_1_1_0 returns AddTerm
	 *     SequenceTerm returns AddTerm
	 *     SequenceTerm.FollowedByTerm_1_0 returns AddTerm
	 *     OrEventTerm returns AddTerm
	 *     OrEventTerm.OrEventTerm_1_0 returns AddTerm
	 *     AndEventTerm returns AddTerm
	 *     AndEventTerm.AndEventTerm_1_0 returns AddTerm
	 *     ConditionalTerm returns AddTerm
	 *     ConditionalTerm.ConditionalTerm_1_0 returns AddTerm
	 *     OrBooleanTerm returns AddTerm
	 *     OrBooleanTerm.OrBooleanTerm_1_0 returns AddTerm
	 *     AndBooleanTerm returns AddTerm
	 *     AndBooleanTerm.AndBooleanTerm_1_0 returns AddTerm
	 *     RelationalTerm returns AddTerm
	 *     RelationalTerm.EqualTerm_1_0_0_0 returns AddTerm
	 *     RelationalTerm.LessThanTerm_1_0_1_0 returns AddTerm
	 *     RelationalTerm.GreaterThanTerm_1_0_2_0 returns AddTerm
	 *     RelationalTerm.LessEqualTerm_1_0_3_0 returns AddTerm
	 *     RelationalTerm.GreaterEqualTerm_1_0_4_0 returns AddTerm
	 *     RelationalTerm.NotEqualTerm_1_0_5_0 returns AddTerm
	 *     AdditionTerm returns AddTerm
	 *     AdditionTerm.AddTerm_1_0_0_0 returns AddTerm
	 *     AdditionTerm.SubTerm_1_0_1_0 returns AddTerm
	 *     MultiplicationTerm returns AddTerm
	 *     MultiplicationTerm.MultTerm_1_0_0_0 returns AddTerm
	 *     MultiplicationTerm.DivTerm_1_0_1_0 returns AddTerm
	 *     PrimaryTerm returns AddTerm
	 *
	 * Constraint:
	 *     (left=AdditionTerm_AddTerm_1_0_0_0 right=MultiplicationTerm)
	 */
	protected void sequence_AdditionTerm(ISerializationContext context, AddTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__LEFT));
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditionTermAccess().getAddTermLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditionTermAccess().getRightMultiplicationTermParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns SubTerm
	 *     WhileTerm returns SubTerm
	 *     WhileTerm.WhileTerm_1_0 returns SubTerm
	 *     RepetionTerm returns SubTerm
	 *     RepetionTerm.RepeatTerm_1_0_0 returns SubTerm
	 *     RepetionTerm.RangeTerm_1_1_0 returns SubTerm
	 *     SequenceTerm returns SubTerm
	 *     SequenceTerm.FollowedByTerm_1_0 returns SubTerm
	 *     OrEventTerm returns SubTerm
	 *     OrEventTerm.OrEventTerm_1_0 returns SubTerm
	 *     AndEventTerm returns SubTerm
	 *     AndEventTerm.AndEventTerm_1_0 returns SubTerm
	 *     ConditionalTerm returns SubTerm
	 *     ConditionalTerm.ConditionalTerm_1_0 returns SubTerm
	 *     OrBooleanTerm returns SubTerm
	 *     OrBooleanTerm.OrBooleanTerm_1_0 returns SubTerm
	 *     AndBooleanTerm returns SubTerm
	 *     AndBooleanTerm.AndBooleanTerm_1_0 returns SubTerm
	 *     RelationalTerm returns SubTerm
	 *     RelationalTerm.EqualTerm_1_0_0_0 returns SubTerm
	 *     RelationalTerm.LessThanTerm_1_0_1_0 returns SubTerm
	 *     RelationalTerm.GreaterThanTerm_1_0_2_0 returns SubTerm
	 *     RelationalTerm.LessEqualTerm_1_0_3_0 returns SubTerm
	 *     RelationalTerm.GreaterEqualTerm_1_0_4_0 returns SubTerm
	 *     RelationalTerm.NotEqualTerm_1_0_5_0 returns SubTerm
	 *     AdditionTerm returns SubTerm
	 *     AdditionTerm.AddTerm_1_0_0_0 returns SubTerm
	 *     AdditionTerm.SubTerm_1_0_1_0 returns SubTerm
	 *     MultiplicationTerm returns SubTerm
	 *     MultiplicationTerm.MultTerm_1_0_0_0 returns SubTerm
	 *     MultiplicationTerm.DivTerm_1_0_1_0 returns SubTerm
	 *     PrimaryTerm returns SubTerm
	 *
	 * Constraint:
	 *     (left=AdditionTerm_SubTerm_1_0_1_0 right=MultiplicationTerm)
	 */
	protected void sequence_AdditionTerm(ISerializationContext context, SubTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__LEFT));
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditionTermAccess().getSubTermLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditionTermAccess().getRightMultiplicationTermParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns AggregationFunction
	 *     WhileTerm returns AggregationFunction
	 *     WhileTerm.WhileTerm_1_0 returns AggregationFunction
	 *     RepetionTerm returns AggregationFunction
	 *     RepetionTerm.RepeatTerm_1_0_0 returns AggregationFunction
	 *     RepetionTerm.RangeTerm_1_1_0 returns AggregationFunction
	 *     SequenceTerm returns AggregationFunction
	 *     SequenceTerm.FollowedByTerm_1_0 returns AggregationFunction
	 *     OrEventTerm returns AggregationFunction
	 *     OrEventTerm.OrEventTerm_1_0 returns AggregationFunction
	 *     AndEventTerm returns AggregationFunction
	 *     AndEventTerm.AndEventTerm_1_0 returns AggregationFunction
	 *     ConditionalTerm returns AggregationFunction
	 *     ConditionalTerm.ConditionalTerm_1_0 returns AggregationFunction
	 *     OrBooleanTerm returns AggregationFunction
	 *     OrBooleanTerm.OrBooleanTerm_1_0 returns AggregationFunction
	 *     AndBooleanTerm returns AggregationFunction
	 *     AndBooleanTerm.AndBooleanTerm_1_0 returns AggregationFunction
	 *     RelationalTerm returns AggregationFunction
	 *     RelationalTerm.EqualTerm_1_0_0_0 returns AggregationFunction
	 *     RelationalTerm.LessThanTerm_1_0_1_0 returns AggregationFunction
	 *     RelationalTerm.GreaterThanTerm_1_0_2_0 returns AggregationFunction
	 *     RelationalTerm.LessEqualTerm_1_0_3_0 returns AggregationFunction
	 *     RelationalTerm.GreaterEqualTerm_1_0_4_0 returns AggregationFunction
	 *     RelationalTerm.NotEqualTerm_1_0_5_0 returns AggregationFunction
	 *     AdditionTerm returns AggregationFunction
	 *     AdditionTerm.AddTerm_1_0_0_0 returns AggregationFunction
	 *     AdditionTerm.SubTerm_1_0_1_0 returns AggregationFunction
	 *     MultiplicationTerm returns AggregationFunction
	 *     MultiplicationTerm.MultTerm_1_0_0_0 returns AggregationFunction
	 *     MultiplicationTerm.DivTerm_1_0_1_0 returns AggregationFunction
	 *     PrimaryTerm returns AggregationFunction
	 *     FunctionTerm returns AggregationFunction
	 *     AggregationFunction returns AggregationFunction
	 *
	 * Constraint:
	 *     ((terms+=VarTerm | terms+=SelfTerm)? name=AggregationFtnEnum (terms+=Term terms+=Term*)?)
	 */
	protected void sequence_AggregationFunction(ISerializationContext context, AggregationFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns AndBooleanTerm
	 *     WhileTerm returns AndBooleanTerm
	 *     WhileTerm.WhileTerm_1_0 returns AndBooleanTerm
	 *     RepetionTerm returns AndBooleanTerm
	 *     RepetionTerm.RepeatTerm_1_0_0 returns AndBooleanTerm
	 *     RepetionTerm.RangeTerm_1_1_0 returns AndBooleanTerm
	 *     SequenceTerm returns AndBooleanTerm
	 *     SequenceTerm.FollowedByTerm_1_0 returns AndBooleanTerm
	 *     OrEventTerm returns AndBooleanTerm
	 *     OrEventTerm.OrEventTerm_1_0 returns AndBooleanTerm
	 *     AndEventTerm returns AndBooleanTerm
	 *     AndEventTerm.AndEventTerm_1_0 returns AndBooleanTerm
	 *     ConditionalTerm returns AndBooleanTerm
	 *     ConditionalTerm.ConditionalTerm_1_0 returns AndBooleanTerm
	 *     OrBooleanTerm returns AndBooleanTerm
	 *     OrBooleanTerm.OrBooleanTerm_1_0 returns AndBooleanTerm
	 *     AndBooleanTerm returns AndBooleanTerm
	 *     AndBooleanTerm.AndBooleanTerm_1_0 returns AndBooleanTerm
	 *     RelationalTerm returns AndBooleanTerm
	 *     RelationalTerm.EqualTerm_1_0_0_0 returns AndBooleanTerm
	 *     RelationalTerm.LessThanTerm_1_0_1_0 returns AndBooleanTerm
	 *     RelationalTerm.GreaterThanTerm_1_0_2_0 returns AndBooleanTerm
	 *     RelationalTerm.LessEqualTerm_1_0_3_0 returns AndBooleanTerm
	 *     RelationalTerm.GreaterEqualTerm_1_0_4_0 returns AndBooleanTerm
	 *     RelationalTerm.NotEqualTerm_1_0_5_0 returns AndBooleanTerm
	 *     AdditionTerm returns AndBooleanTerm
	 *     AdditionTerm.AddTerm_1_0_0_0 returns AndBooleanTerm
	 *     AdditionTerm.SubTerm_1_0_1_0 returns AndBooleanTerm
	 *     MultiplicationTerm returns AndBooleanTerm
	 *     MultiplicationTerm.MultTerm_1_0_0_0 returns AndBooleanTerm
	 *     MultiplicationTerm.DivTerm_1_0_1_0 returns AndBooleanTerm
	 *     PrimaryTerm returns AndBooleanTerm
	 *
	 * Constraint:
	 *     (left=AndBooleanTerm_AndBooleanTerm_1_0 (right=NotBooleanTerm | right=RelationalTerm))
	 */
	protected void sequence_AndBooleanTerm(ISerializationContext context, AndBooleanTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns AndEventTerm
	 *     WhileTerm returns AndEventTerm
	 *     WhileTerm.WhileTerm_1_0 returns AndEventTerm
	 *     RepetionTerm returns AndEventTerm
	 *     RepetionTerm.RepeatTerm_1_0_0 returns AndEventTerm
	 *     RepetionTerm.RangeTerm_1_1_0 returns AndEventTerm
	 *     SequenceTerm returns AndEventTerm
	 *     SequenceTerm.FollowedByTerm_1_0 returns AndEventTerm
	 *     OrEventTerm returns AndEventTerm
	 *     OrEventTerm.OrEventTerm_1_0 returns AndEventTerm
	 *     AndEventTerm returns AndEventTerm
	 *     AndEventTerm.AndEventTerm_1_0 returns AndEventTerm
	 *     ConditionalTerm returns AndEventTerm
	 *     ConditionalTerm.ConditionalTerm_1_0 returns AndEventTerm
	 *     OrBooleanTerm returns AndEventTerm
	 *     OrBooleanTerm.OrBooleanTerm_1_0 returns AndEventTerm
	 *     AndBooleanTerm returns AndEventTerm
	 *     AndBooleanTerm.AndBooleanTerm_1_0 returns AndEventTerm
	 *     RelationalTerm returns AndEventTerm
	 *     RelationalTerm.EqualTerm_1_0_0_0 returns AndEventTerm
	 *     RelationalTerm.LessThanTerm_1_0_1_0 returns AndEventTerm
	 *     RelationalTerm.GreaterThanTerm_1_0_2_0 returns AndEventTerm
	 *     RelationalTerm.LessEqualTerm_1_0_3_0 returns AndEventTerm
	 *     RelationalTerm.GreaterEqualTerm_1_0_4_0 returns AndEventTerm
	 *     RelationalTerm.NotEqualTerm_1_0_5_0 returns AndEventTerm
	 *     AdditionTerm returns AndEventTerm
	 *     AdditionTerm.AddTerm_1_0_0_0 returns AndEventTerm
	 *     AdditionTerm.SubTerm_1_0_1_0 returns AndEventTerm
	 *     MultiplicationTerm returns AndEventTerm
	 *     MultiplicationTerm.MultTerm_1_0_0_0 returns AndEventTerm
	 *     MultiplicationTerm.DivTerm_1_0_1_0 returns AndEventTerm
	 *     PrimaryTerm returns AndEventTerm
	 *
	 * Constraint:
	 *     (left=AndEventTerm_AndEventTerm_1_0 (right=NotEventTerm | right=ConditionalTerm))
	 */
	protected void sequence_AndEventTerm(ISerializationContext context, AndEventTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns ArithFunction
	 *     WhileTerm returns ArithFunction
	 *     WhileTerm.WhileTerm_1_0 returns ArithFunction
	 *     RepetionTerm returns ArithFunction
	 *     RepetionTerm.RepeatTerm_1_0_0 returns ArithFunction
	 *     RepetionTerm.RangeTerm_1_1_0 returns ArithFunction
	 *     SequenceTerm returns ArithFunction
	 *     SequenceTerm.FollowedByTerm_1_0 returns ArithFunction
	 *     OrEventTerm returns ArithFunction
	 *     OrEventTerm.OrEventTerm_1_0 returns ArithFunction
	 *     AndEventTerm returns ArithFunction
	 *     AndEventTerm.AndEventTerm_1_0 returns ArithFunction
	 *     ConditionalTerm returns ArithFunction
	 *     ConditionalTerm.ConditionalTerm_1_0 returns ArithFunction
	 *     OrBooleanTerm returns ArithFunction
	 *     OrBooleanTerm.OrBooleanTerm_1_0 returns ArithFunction
	 *     AndBooleanTerm returns ArithFunction
	 *     AndBooleanTerm.AndBooleanTerm_1_0 returns ArithFunction
	 *     RelationalTerm returns ArithFunction
	 *     RelationalTerm.EqualTerm_1_0_0_0 returns ArithFunction
	 *     RelationalTerm.LessThanTerm_1_0_1_0 returns ArithFunction
	 *     RelationalTerm.GreaterThanTerm_1_0_2_0 returns ArithFunction
	 *     RelationalTerm.LessEqualTerm_1_0_3_0 returns ArithFunction
	 *     RelationalTerm.GreaterEqualTerm_1_0_4_0 returns ArithFunction
	 *     RelationalTerm.NotEqualTerm_1_0_5_0 returns ArithFunction
	 *     AdditionTerm returns ArithFunction
	 *     AdditionTerm.AddTerm_1_0_0_0 returns ArithFunction
	 *     AdditionTerm.SubTerm_1_0_1_0 returns ArithFunction
	 *     MultiplicationTerm returns ArithFunction
	 *     MultiplicationTerm.MultTerm_1_0_0_0 returns ArithFunction
	 *     MultiplicationTerm.DivTerm_1_0_1_0 returns ArithFunction
	 *     PrimaryTerm returns ArithFunction
	 *     FunctionTerm returns ArithFunction
	 *     ArithFunction returns ArithFunction
	 *
	 * Constraint:
	 *     ((terms+=VarTerm | terms+=SelfTerm)? name=ArithFtnEnum (terms+=Term terms+=Term*)?)
	 */
	protected void sequence_ArithFunction(ISerializationContext context, ArithFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypedVariable returns BeliefVariable
	 *     BeliefVariable returns BeliefVariable
	 *     BeliefVariableImpl returns BeliefVariable
	 *
	 * Constraint:
	 *     (description=ElementDescription? name=ID declaration=InbuiltDeclaration (reference=EDouble | survival=TimeValue)*)
	 */
	protected void sequence_BeliefVariableImpl(ISerializationContext context, BeliefVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BooleanArray returns ArrayValue
	 *
	 * Constraint:
	 *     (values+=BooleanValue values+=BooleanValue*)
	 */
	protected void sequence_BooleanArray(ISerializationContext context, ArrayValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypedValue returns ArrayValue
	 *     ArrayValue returns ArrayValue
	 *
	 * Constraint:
	 *     (
	 *         (values+=BooleanValue values+=BooleanValue*) | 
	 *         (values+=EnumValue values+=EnumValue*) | 
	 *         (values+=NumericValue_Impl values+=NumericValue_Impl*) | 
	 *         (values+=UnitMeasuredValue_Impl values+=UnitMeasuredValue_Impl*) | 
	 *         (values+=TimeValue values+=TimeValue*)
	 *     )
	 */
	protected void sequence_BooleanArray_EnumArray_NumericArray_Impl_TimeArray_UnitMeasuredArray_Impl(ISerializationContext context, ArrayValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns BooleanType
	 *     BooleanType returns BooleanType
	 *
	 * Constraint:
	 *     cardinality=INT?
	 */
	protected void sequence_BooleanType(ISerializationContext context, BooleanType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypedValue returns BooleanValue
	 *     SingleValue returns BooleanValue
	 *     BooleanValue returns BooleanValue
	 *
	 * Constraint:
	 *     value=EBoolean
	 */
	protected void sequence_BooleanValue(ISerializationContext context, BooleanValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DatatypesPackage.Literals.BOOLEAN_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DatatypesPackage.Literals.BOOLEAN_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanValueAccess().getValueEBooleanParserRuleCall_1_0(), semanticObject.isValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Action returns ClearEvidence
	 *     ClearEvidence returns ClearEvidence
	 *
	 * Constraint:
	 *     target=[BeliefVariable|QualifiedName]
	 */
	protected void sequence_ClearEvidence(ISerializationContext context, ClearEvidence semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KernelPackage.Literals.CLEAR_EVIDENCE__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KernelPackage.Literals.CLEAR_EVIDENCE__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getClearEvidenceAccess().getTargetBeliefVariableQualifiedNameParserRuleCall_1_0_1(), semanticObject.eGet(KernelPackage.Literals.CLEAR_EVIDENCE__TARGET, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns CollectionFunction
	 *     WhileTerm returns CollectionFunction
	 *     WhileTerm.WhileTerm_1_0 returns CollectionFunction
	 *     RepetionTerm returns CollectionFunction
	 *     RepetionTerm.RepeatTerm_1_0_0 returns CollectionFunction
	 *     RepetionTerm.RangeTerm_1_1_0 returns CollectionFunction
	 *     SequenceTerm returns CollectionFunction
	 *     SequenceTerm.FollowedByTerm_1_0 returns CollectionFunction
	 *     OrEventTerm returns CollectionFunction
	 *     OrEventTerm.OrEventTerm_1_0 returns CollectionFunction
	 *     AndEventTerm returns CollectionFunction
	 *     AndEventTerm.AndEventTerm_1_0 returns CollectionFunction
	 *     ConditionalTerm returns CollectionFunction
	 *     ConditionalTerm.ConditionalTerm_1_0 returns CollectionFunction
	 *     OrBooleanTerm returns CollectionFunction
	 *     OrBooleanTerm.OrBooleanTerm_1_0 returns CollectionFunction
	 *     AndBooleanTerm returns CollectionFunction
	 *     AndBooleanTerm.AndBooleanTerm_1_0 returns CollectionFunction
	 *     RelationalTerm returns CollectionFunction
	 *     RelationalTerm.EqualTerm_1_0_0_0 returns CollectionFunction
	 *     RelationalTerm.LessThanTerm_1_0_1_0 returns CollectionFunction
	 *     RelationalTerm.GreaterThanTerm_1_0_2_0 returns CollectionFunction
	 *     RelationalTerm.LessEqualTerm_1_0_3_0 returns CollectionFunction
	 *     RelationalTerm.GreaterEqualTerm_1_0_4_0 returns CollectionFunction
	 *     RelationalTerm.NotEqualTerm_1_0_5_0 returns CollectionFunction
	 *     AdditionTerm returns CollectionFunction
	 *     AdditionTerm.AddTerm_1_0_0_0 returns CollectionFunction
	 *     AdditionTerm.SubTerm_1_0_1_0 returns CollectionFunction
	 *     MultiplicationTerm returns CollectionFunction
	 *     MultiplicationTerm.MultTerm_1_0_0_0 returns CollectionFunction
	 *     MultiplicationTerm.DivTerm_1_0_1_0 returns CollectionFunction
	 *     PrimaryTerm returns CollectionFunction
	 *     FunctionTerm returns CollectionFunction
	 *     CollectionFunction returns CollectionFunction
	 *
	 * Constraint:
	 *     ((terms+=VarTerm | terms+=SelfTerm)? name=CollectionFtnEnum (terms+=Term terms+=Term*)?)
	 */
	protected void sequence_CollectionFunction(ISerializationContext context, CollectionFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns ConditionalTerm
	 *     WhileTerm returns ConditionalTerm
	 *     WhileTerm.WhileTerm_1_0 returns ConditionalTerm
	 *     RepetionTerm returns ConditionalTerm
	 *     RepetionTerm.RepeatTerm_1_0_0 returns ConditionalTerm
	 *     RepetionTerm.RangeTerm_1_1_0 returns ConditionalTerm
	 *     SequenceTerm returns ConditionalTerm
	 *     SequenceTerm.FollowedByTerm_1_0 returns ConditionalTerm
	 *     OrEventTerm returns ConditionalTerm
	 *     OrEventTerm.OrEventTerm_1_0 returns ConditionalTerm
	 *     AndEventTerm returns ConditionalTerm
	 *     AndEventTerm.AndEventTerm_1_0 returns ConditionalTerm
	 *     ConditionalTerm returns ConditionalTerm
	 *     ConditionalTerm.ConditionalTerm_1_0 returns ConditionalTerm
	 *     OrBooleanTerm returns ConditionalTerm
	 *     OrBooleanTerm.OrBooleanTerm_1_0 returns ConditionalTerm
	 *     AndBooleanTerm returns ConditionalTerm
	 *     AndBooleanTerm.AndBooleanTerm_1_0 returns ConditionalTerm
	 *     RelationalTerm returns ConditionalTerm
	 *     RelationalTerm.EqualTerm_1_0_0_0 returns ConditionalTerm
	 *     RelationalTerm.LessThanTerm_1_0_1_0 returns ConditionalTerm
	 *     RelationalTerm.GreaterThanTerm_1_0_2_0 returns ConditionalTerm
	 *     RelationalTerm.LessEqualTerm_1_0_3_0 returns ConditionalTerm
	 *     RelationalTerm.GreaterEqualTerm_1_0_4_0 returns ConditionalTerm
	 *     RelationalTerm.NotEqualTerm_1_0_5_0 returns ConditionalTerm
	 *     AdditionTerm returns ConditionalTerm
	 *     AdditionTerm.AddTerm_1_0_0_0 returns ConditionalTerm
	 *     AdditionTerm.SubTerm_1_0_1_0 returns ConditionalTerm
	 *     MultiplicationTerm returns ConditionalTerm
	 *     MultiplicationTerm.MultTerm_1_0_0_0 returns ConditionalTerm
	 *     MultiplicationTerm.DivTerm_1_0_1_0 returns ConditionalTerm
	 *     PrimaryTerm returns ConditionalTerm
	 *
	 * Constraint:
	 *     (terms+=ConditionalTerm_ConditionalTerm_1_0 terms+=OrBooleanTerm terms+=ConditionalTerm)
	 */
	protected void sequence_ConditionalTerm(ISerializationContext context, ConditionalTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns ConstTerm
	 *     WhileTerm returns ConstTerm
	 *     WhileTerm.WhileTerm_1_0 returns ConstTerm
	 *     RepetionTerm returns ConstTerm
	 *     RepetionTerm.RepeatTerm_1_0_0 returns ConstTerm
	 *     RepetionTerm.RangeTerm_1_1_0 returns ConstTerm
	 *     SequenceTerm returns ConstTerm
	 *     SequenceTerm.FollowedByTerm_1_0 returns ConstTerm
	 *     OrEventTerm returns ConstTerm
	 *     OrEventTerm.OrEventTerm_1_0 returns ConstTerm
	 *     AndEventTerm returns ConstTerm
	 *     AndEventTerm.AndEventTerm_1_0 returns ConstTerm
	 *     ConditionalTerm returns ConstTerm
	 *     ConditionalTerm.ConditionalTerm_1_0 returns ConstTerm
	 *     OrBooleanTerm returns ConstTerm
	 *     OrBooleanTerm.OrBooleanTerm_1_0 returns ConstTerm
	 *     AndBooleanTerm returns ConstTerm
	 *     AndBooleanTerm.AndBooleanTerm_1_0 returns ConstTerm
	 *     RelationalTerm returns ConstTerm
	 *     RelationalTerm.EqualTerm_1_0_0_0 returns ConstTerm
	 *     RelationalTerm.LessThanTerm_1_0_1_0 returns ConstTerm
	 *     RelationalTerm.GreaterThanTerm_1_0_2_0 returns ConstTerm
	 *     RelationalTerm.LessEqualTerm_1_0_3_0 returns ConstTerm
	 *     RelationalTerm.GreaterEqualTerm_1_0_4_0 returns ConstTerm
	 *     RelationalTerm.NotEqualTerm_1_0_5_0 returns ConstTerm
	 *     AdditionTerm returns ConstTerm
	 *     AdditionTerm.AddTerm_1_0_0_0 returns ConstTerm
	 *     AdditionTerm.SubTerm_1_0_1_0 returns ConstTerm
	 *     MultiplicationTerm returns ConstTerm
	 *     MultiplicationTerm.MultTerm_1_0_0_0 returns ConstTerm
	 *     MultiplicationTerm.DivTerm_1_0_1_0 returns ConstTerm
	 *     PrimaryTerm returns ConstTerm
	 *     ConstTerm returns ConstTerm
	 *
	 * Constraint:
	 *     value=TypedValue
	 */
	protected void sequence_ConstTerm(ISerializationContext context, ConstTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.CONST_TERM__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.CONST_TERM__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstTermAccess().getValueTypedValueParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DataTypeDeclaration returns ContainedDeclaration
	 *     ContainedDeclaration returns ContainedDeclaration
	 *
	 * Constraint:
	 *     type=DataType
	 */
	protected void sequence_ContainedDeclaration(ISerializationContext context, ContainedDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DatatypesPackage.Literals.CONTAINED_DECLARATION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DatatypesPackage.Literals.CONTAINED_DECLARATION__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getContainedDeclarationAccess().getTypeDataTypeParserRuleCall_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ContextPattern returns ContextPattern
	 *
	 * Constraint:
	 *     term=Term
	 */
	protected void sequence_ContextPattern(ISerializationContext context, ContextPattern semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.CONTEXT_PATTERN__TERM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.CONTEXT_PATTERN__TERM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getContextPatternAccess().getTermTermParserRuleCall_0(), semanticObject.getTerm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DataTypeDefinition returns DataTypeDefinition
	 *
	 * Constraint:
	 *     (name=EString dataType=DataType)
	 */
	protected void sequence_DataTypeDefinition(ISerializationContext context, DataTypeDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DatatypesPackage.Literals.DATA_TYPE_DEFINITION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DatatypesPackage.Literals.DATA_TYPE_DEFINITION__NAME));
			if (transientValues.isValueTransient(semanticObject, DatatypesPackage.Literals.DATA_TYPE_DEFINITION__DATA_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DatatypesPackage.Literals.DATA_TYPE_DEFINITION__DATA_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDataTypeDefinitionAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getDataTypeDefinitionAccess().getDataTypeDataTypeParserRuleCall_3_0(), semanticObject.getDataType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypedVariable returns DerivedContext
	 *     Context returns DerivedContext
	 *     DerivedContext returns DerivedContext
	 *
	 * Constraint:
	 *     (description=ElementDescription? name=ID declaration=DataTypeDeclaration definition=ContextPattern)
	 */
	protected void sequence_DerivedContext(ISerializationContext context, DerivedContext semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnumArray returns ArrayValue
	 *
	 * Constraint:
	 *     (values+=EnumValue values+=EnumValue*)
	 */
	protected void sequence_EnumArray(ISerializationContext context, ArrayValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnumLiteral returns EnumLiteral
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_EnumLiteral(ISerializationContext context, EnumLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DatatypesPackage.Literals.ENUM_LITERAL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DatatypesPackage.Literals.ENUM_LITERAL__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumLiteralAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns EnumType
	 *     EnumType returns EnumType
	 *
	 * Constraint:
	 *     (cardinality=INT? literals+=EnumLiteral literals+=EnumLiteral+)
	 */
	protected void sequence_EnumType(ISerializationContext context, EnumType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypedValue returns EnumValue
	 *     SingleValue returns EnumValue
	 *     EnumValue returns EnumValue
	 *
	 * Constraint:
	 *     value=[EnumLiteral|LiteralQualifiedName]
	 */
	protected void sequence_EnumValue(ISerializationContext context, EnumValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DatatypesPackage.Literals.ENUM_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DatatypesPackage.Literals.ENUM_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumValueAccess().getValueEnumLiteralLiteralQualifiedNameParserRuleCall_1_0_1(), semanticObject.eGet(DatatypesPackage.Literals.ENUM_VALUE__VALUE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns EventType
	 *     EventType returns EventType
	 *
	 * Constraint:
	 *     cardinality=INT?
	 */
	protected void sequence_EventType(ISerializationContext context, EventType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypedValue returns EventValue
	 *     SingleValue returns EventValue
	 *     EventValue returns EventValue
	 *
	 * Constraint:
	 *     {EventValue}
	 */
	protected void sequence_EventValue(ISerializationContext context, EventValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GeneralExpression returns GeneralExpression
	 *
	 * Constraint:
	 *     term=Term
	 */
	protected void sequence_GeneralExpression(ISerializationContext context, GeneralExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.GENERAL_EXPRESSION__TERM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.GENERAL_EXPRESSION__TERM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGeneralExpressionAccess().getTermTermParserRuleCall_0(), semanticObject.getTerm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypedVariable returns GeneralPurposeVariable
	 *     GeneralPurposeVariable returns GeneralPurposeVariable
	 *
	 * Constraint:
	 *     (name=ID declaration=DataTypeDeclaration definition=GeneralExpression)
	 */
	protected void sequence_GeneralPurposeVariable(ISerializationContext context, GeneralPurposeVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DatatypesPackage.Literals.TYPED_VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DatatypesPackage.Literals.TYPED_VARIABLE__NAME));
			if (transientValues.isValueTransient(semanticObject, DatatypesPackage.Literals.TYPED_VARIABLE__DECLARATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DatatypesPackage.Literals.TYPED_VARIABLE__DECLARATION));
			if (transientValues.isValueTransient(semanticObject, KernelPackage.Literals.GENERAL_PURPOSE_VARIABLE__DEFINITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KernelPackage.Literals.GENERAL_PURPOSE_VARIABLE__DEFINITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGeneralPurposeVariableAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getGeneralPurposeVariableAccess().getDeclarationDataTypeDeclarationParserRuleCall_3_0(), semanticObject.getDeclaration());
		feeder.accept(grammarAccess.getGeneralPurposeVariableAccess().getDefinitionGeneralExpressionParserRuleCall_4_1_0(), semanticObject.getDefinition());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importURI=EString
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KernelPackage.Literals.IMPORT__IMPORT_URI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KernelPackage.Literals.IMPORT__IMPORT_URI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportURIEStringParserRuleCall_1_0(), semanticObject.getImportURI());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DataTypeDeclaration returns InbuiltDeclaration
	 *     InbuiltDeclaration returns InbuiltDeclaration
	 *
	 * Constraint:
	 *     {InbuiltDeclaration}
	 */
	protected void sequence_InbuiltDeclaration(ISerializationContext context, InbuiltDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NumericTypeConstraint returns LowerBound
	 *     LowerBound returns LowerBound
	 *
	 * Constraint:
	 *     value=EDouble
	 */
	protected void sequence_LowerBound(ISerializationContext context, LowerBound semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DatatypesPackage.Literals.LOWER_BOUND__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DatatypesPackage.Literals.LOWER_BOUND__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLowerBoundAccess().getValueEDoubleParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns DivTerm
	 *     WhileTerm returns DivTerm
	 *     WhileTerm.WhileTerm_1_0 returns DivTerm
	 *     RepetionTerm returns DivTerm
	 *     RepetionTerm.RepeatTerm_1_0_0 returns DivTerm
	 *     RepetionTerm.RangeTerm_1_1_0 returns DivTerm
	 *     SequenceTerm returns DivTerm
	 *     SequenceTerm.FollowedByTerm_1_0 returns DivTerm
	 *     OrEventTerm returns DivTerm
	 *     OrEventTerm.OrEventTerm_1_0 returns DivTerm
	 *     AndEventTerm returns DivTerm
	 *     AndEventTerm.AndEventTerm_1_0 returns DivTerm
	 *     ConditionalTerm returns DivTerm
	 *     ConditionalTerm.ConditionalTerm_1_0 returns DivTerm
	 *     OrBooleanTerm returns DivTerm
	 *     OrBooleanTerm.OrBooleanTerm_1_0 returns DivTerm
	 *     AndBooleanTerm returns DivTerm
	 *     AndBooleanTerm.AndBooleanTerm_1_0 returns DivTerm
	 *     RelationalTerm returns DivTerm
	 *     RelationalTerm.EqualTerm_1_0_0_0 returns DivTerm
	 *     RelationalTerm.LessThanTerm_1_0_1_0 returns DivTerm
	 *     RelationalTerm.GreaterThanTerm_1_0_2_0 returns DivTerm
	 *     RelationalTerm.LessEqualTerm_1_0_3_0 returns DivTerm
	 *     RelationalTerm.GreaterEqualTerm_1_0_4_0 returns DivTerm
	 *     RelationalTerm.NotEqualTerm_1_0_5_0 returns DivTerm
	 *     AdditionTerm returns DivTerm
	 *     AdditionTerm.AddTerm_1_0_0_0 returns DivTerm
	 *     AdditionTerm.SubTerm_1_0_1_0 returns DivTerm
	 *     MultiplicationTerm returns DivTerm
	 *     MultiplicationTerm.MultTerm_1_0_0_0 returns DivTerm
	 *     MultiplicationTerm.DivTerm_1_0_1_0 returns DivTerm
	 *     PrimaryTerm returns DivTerm
	 *
	 * Constraint:
	 *     (left=MultiplicationTerm_DivTerm_1_0_1_0 right=PrimaryTerm)
	 */
	protected void sequence_MultiplicationTerm(ISerializationContext context, DivTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__LEFT));
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationTermAccess().getDivTermLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicationTermAccess().getRightPrimaryTermParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns MultTerm
	 *     WhileTerm returns MultTerm
	 *     WhileTerm.WhileTerm_1_0 returns MultTerm
	 *     RepetionTerm returns MultTerm
	 *     RepetionTerm.RepeatTerm_1_0_0 returns MultTerm
	 *     RepetionTerm.RangeTerm_1_1_0 returns MultTerm
	 *     SequenceTerm returns MultTerm
	 *     SequenceTerm.FollowedByTerm_1_0 returns MultTerm
	 *     OrEventTerm returns MultTerm
	 *     OrEventTerm.OrEventTerm_1_0 returns MultTerm
	 *     AndEventTerm returns MultTerm
	 *     AndEventTerm.AndEventTerm_1_0 returns MultTerm
	 *     ConditionalTerm returns MultTerm
	 *     ConditionalTerm.ConditionalTerm_1_0 returns MultTerm
	 *     OrBooleanTerm returns MultTerm
	 *     OrBooleanTerm.OrBooleanTerm_1_0 returns MultTerm
	 *     AndBooleanTerm returns MultTerm
	 *     AndBooleanTerm.AndBooleanTerm_1_0 returns MultTerm
	 *     RelationalTerm returns MultTerm
	 *     RelationalTerm.EqualTerm_1_0_0_0 returns MultTerm
	 *     RelationalTerm.LessThanTerm_1_0_1_0 returns MultTerm
	 *     RelationalTerm.GreaterThanTerm_1_0_2_0 returns MultTerm
	 *     RelationalTerm.LessEqualTerm_1_0_3_0 returns MultTerm
	 *     RelationalTerm.GreaterEqualTerm_1_0_4_0 returns MultTerm
	 *     RelationalTerm.NotEqualTerm_1_0_5_0 returns MultTerm
	 *     AdditionTerm returns MultTerm
	 *     AdditionTerm.AddTerm_1_0_0_0 returns MultTerm
	 *     AdditionTerm.SubTerm_1_0_1_0 returns MultTerm
	 *     MultiplicationTerm returns MultTerm
	 *     MultiplicationTerm.MultTerm_1_0_0_0 returns MultTerm
	 *     MultiplicationTerm.DivTerm_1_0_1_0 returns MultTerm
	 *     PrimaryTerm returns MultTerm
	 *
	 * Constraint:
	 *     (left=MultiplicationTerm_MultTerm_1_0_0_0 right=PrimaryTerm)
	 */
	protected void sequence_MultiplicationTerm(ISerializationContext context, MultTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__LEFT));
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationTermAccess().getMultTermLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicationTermAccess().getRightPrimaryTermParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns NotBooleanTerm
	 *     WhileTerm returns NotBooleanTerm
	 *     WhileTerm.WhileTerm_1_0 returns NotBooleanTerm
	 *     RepetionTerm returns NotBooleanTerm
	 *     RepetionTerm.RepeatTerm_1_0_0 returns NotBooleanTerm
	 *     RepetionTerm.RangeTerm_1_1_0 returns NotBooleanTerm
	 *     SequenceTerm returns NotBooleanTerm
	 *     SequenceTerm.FollowedByTerm_1_0 returns NotBooleanTerm
	 *     OrEventTerm returns NotBooleanTerm
	 *     OrEventTerm.OrEventTerm_1_0 returns NotBooleanTerm
	 *     AndEventTerm returns NotBooleanTerm
	 *     AndEventTerm.AndEventTerm_1_0 returns NotBooleanTerm
	 *     ConditionalTerm returns NotBooleanTerm
	 *     ConditionalTerm.ConditionalTerm_1_0 returns NotBooleanTerm
	 *     OrBooleanTerm returns NotBooleanTerm
	 *     OrBooleanTerm.OrBooleanTerm_1_0 returns NotBooleanTerm
	 *     AndBooleanTerm returns NotBooleanTerm
	 *     AndBooleanTerm.AndBooleanTerm_1_0 returns NotBooleanTerm
	 *     NotBooleanTerm returns NotBooleanTerm
	 *     RelationalTerm returns NotBooleanTerm
	 *     RelationalTerm.EqualTerm_1_0_0_0 returns NotBooleanTerm
	 *     RelationalTerm.LessThanTerm_1_0_1_0 returns NotBooleanTerm
	 *     RelationalTerm.GreaterThanTerm_1_0_2_0 returns NotBooleanTerm
	 *     RelationalTerm.LessEqualTerm_1_0_3_0 returns NotBooleanTerm
	 *     RelationalTerm.GreaterEqualTerm_1_0_4_0 returns NotBooleanTerm
	 *     RelationalTerm.NotEqualTerm_1_0_5_0 returns NotBooleanTerm
	 *     AdditionTerm returns NotBooleanTerm
	 *     AdditionTerm.AddTerm_1_0_0_0 returns NotBooleanTerm
	 *     AdditionTerm.SubTerm_1_0_1_0 returns NotBooleanTerm
	 *     MultiplicationTerm returns NotBooleanTerm
	 *     MultiplicationTerm.MultTerm_1_0_0_0 returns NotBooleanTerm
	 *     MultiplicationTerm.DivTerm_1_0_1_0 returns NotBooleanTerm
	 *     PrimaryTerm returns NotBooleanTerm
	 *
	 * Constraint:
	 *     term=RelationalTerm
	 */
	protected void sequence_NotBooleanTerm(ISerializationContext context, NotBooleanTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.UNARY_TERM_OP__TERM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.UNARY_TERM_OP__TERM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotBooleanTermAccess().getTermRelationalTermParserRuleCall_2_0(), semanticObject.getTerm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns NotEventTerm
	 *     WhileTerm returns NotEventTerm
	 *     WhileTerm.WhileTerm_1_0 returns NotEventTerm
	 *     RepetionTerm returns NotEventTerm
	 *     RepetionTerm.RepeatTerm_1_0_0 returns NotEventTerm
	 *     RepetionTerm.RangeTerm_1_1_0 returns NotEventTerm
	 *     SequenceTerm returns NotEventTerm
	 *     SequenceTerm.FollowedByTerm_1_0 returns NotEventTerm
	 *     OrEventTerm returns NotEventTerm
	 *     OrEventTerm.OrEventTerm_1_0 returns NotEventTerm
	 *     AndEventTerm returns NotEventTerm
	 *     AndEventTerm.AndEventTerm_1_0 returns NotEventTerm
	 *     NotEventTerm returns NotEventTerm
	 *     ConditionalTerm returns NotEventTerm
	 *     ConditionalTerm.ConditionalTerm_1_0 returns NotEventTerm
	 *     OrBooleanTerm returns NotEventTerm
	 *     OrBooleanTerm.OrBooleanTerm_1_0 returns NotEventTerm
	 *     AndBooleanTerm returns NotEventTerm
	 *     AndBooleanTerm.AndBooleanTerm_1_0 returns NotEventTerm
	 *     RelationalTerm returns NotEventTerm
	 *     RelationalTerm.EqualTerm_1_0_0_0 returns NotEventTerm
	 *     RelationalTerm.LessThanTerm_1_0_1_0 returns NotEventTerm
	 *     RelationalTerm.GreaterThanTerm_1_0_2_0 returns NotEventTerm
	 *     RelationalTerm.LessEqualTerm_1_0_3_0 returns NotEventTerm
	 *     RelationalTerm.GreaterEqualTerm_1_0_4_0 returns NotEventTerm
	 *     RelationalTerm.NotEqualTerm_1_0_5_0 returns NotEventTerm
	 *     AdditionTerm returns NotEventTerm
	 *     AdditionTerm.AddTerm_1_0_0_0 returns NotEventTerm
	 *     AdditionTerm.SubTerm_1_0_1_0 returns NotEventTerm
	 *     MultiplicationTerm returns NotEventTerm
	 *     MultiplicationTerm.MultTerm_1_0_0_0 returns NotEventTerm
	 *     MultiplicationTerm.DivTerm_1_0_1_0 returns NotEventTerm
	 *     PrimaryTerm returns NotEventTerm
	 *
	 * Constraint:
	 *     term=ConditionalTerm
	 */
	protected void sequence_NotEventTerm(ISerializationContext context, NotEventTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.UNARY_TERM_OP__TERM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.UNARY_TERM_OP__TERM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotEventTermAccess().getTermConditionalTermParserRuleCall_2_0(), semanticObject.getTerm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NumericArray_Impl returns ArrayValue
	 *
	 * Constraint:
	 *     (values+=NumericValue_Impl values+=NumericValue_Impl*)
	 */
	protected void sequence_NumericArray_Impl(ISerializationContext context, ArrayValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NumericArray returns ArrayValue
	 *
	 * Constraint:
	 *     (
	 *         (values+=NumericValue_Impl values+=NumericValue_Impl*) | 
	 *         (values+=UnitMeasuredValue_Impl values+=UnitMeasuredValue_Impl*) | 
	 *         (values+=TimeValue values+=TimeValue*)
	 *     )
	 */
	protected void sequence_NumericArray_Impl_TimeArray_UnitMeasuredArray_Impl(ISerializationContext context, ArrayValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns NumericType
	 *     NumericType returns NumericType
	 *
	 * Constraint:
	 *     (cardinality=INT? constraints+=NumericTypeConstraint*)
	 */
	protected void sequence_NumericType(ISerializationContext context, NumericType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypedValue returns NumericValue
	 *     SingleValue returns NumericValue
	 *     NumericValue returns NumericValue
	 *     NumericValue_Impl returns NumericValue
	 *
	 * Constraint:
	 *     value=EDouble
	 */
	protected void sequence_NumericValue_Impl(ISerializationContext context, NumericValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DatatypesPackage.Literals.NUMERIC_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DatatypesPackage.Literals.NUMERIC_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumericValue_ImplAccess().getValueEDoubleParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Sentence returns Observation
	 *     Observation returns Observation
	 *
	 * Constraint:
	 *     (description=ElementDescription? name=ID pattern=ContextPattern (actions+=Action | actions+=Action+))
	 */
	protected void sequence_Observation(ISerializationContext context, Observation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns OnceTerm
	 *     OnceTerm returns OnceTerm
	 *     WhileTerm returns OnceTerm
	 *     WhileTerm.WhileTerm_1_0 returns OnceTerm
	 *     RepetionTerm returns OnceTerm
	 *     RepetionTerm.RepeatTerm_1_0_0 returns OnceTerm
	 *     RepetionTerm.RangeTerm_1_1_0 returns OnceTerm
	 *     SequenceTerm returns OnceTerm
	 *     SequenceTerm.FollowedByTerm_1_0 returns OnceTerm
	 *     OrEventTerm returns OnceTerm
	 *     OrEventTerm.OrEventTerm_1_0 returns OnceTerm
	 *     AndEventTerm returns OnceTerm
	 *     AndEventTerm.AndEventTerm_1_0 returns OnceTerm
	 *     ConditionalTerm returns OnceTerm
	 *     ConditionalTerm.ConditionalTerm_1_0 returns OnceTerm
	 *     OrBooleanTerm returns OnceTerm
	 *     OrBooleanTerm.OrBooleanTerm_1_0 returns OnceTerm
	 *     AndBooleanTerm returns OnceTerm
	 *     AndBooleanTerm.AndBooleanTerm_1_0 returns OnceTerm
	 *     RelationalTerm returns OnceTerm
	 *     RelationalTerm.EqualTerm_1_0_0_0 returns OnceTerm
	 *     RelationalTerm.LessThanTerm_1_0_1_0 returns OnceTerm
	 *     RelationalTerm.GreaterThanTerm_1_0_2_0 returns OnceTerm
	 *     RelationalTerm.LessEqualTerm_1_0_3_0 returns OnceTerm
	 *     RelationalTerm.GreaterEqualTerm_1_0_4_0 returns OnceTerm
	 *     RelationalTerm.NotEqualTerm_1_0_5_0 returns OnceTerm
	 *     AdditionTerm returns OnceTerm
	 *     AdditionTerm.AddTerm_1_0_0_0 returns OnceTerm
	 *     AdditionTerm.SubTerm_1_0_1_0 returns OnceTerm
	 *     MultiplicationTerm returns OnceTerm
	 *     MultiplicationTerm.MultTerm_1_0_0_0 returns OnceTerm
	 *     MultiplicationTerm.DivTerm_1_0_1_0 returns OnceTerm
	 *     PrimaryTerm returns OnceTerm
	 *
	 * Constraint:
	 *     term=WhileTerm
	 */
	protected void sequence_OnceTerm(ISerializationContext context, OnceTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.UNARY_TERM_OP__TERM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.UNARY_TERM_OP__TERM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOnceTermAccess().getTermWhileTermParserRuleCall_1_0(), semanticObject.getTerm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns OrBooleanTerm
	 *     WhileTerm returns OrBooleanTerm
	 *     WhileTerm.WhileTerm_1_0 returns OrBooleanTerm
	 *     RepetionTerm returns OrBooleanTerm
	 *     RepetionTerm.RepeatTerm_1_0_0 returns OrBooleanTerm
	 *     RepetionTerm.RangeTerm_1_1_0 returns OrBooleanTerm
	 *     SequenceTerm returns OrBooleanTerm
	 *     SequenceTerm.FollowedByTerm_1_0 returns OrBooleanTerm
	 *     OrEventTerm returns OrBooleanTerm
	 *     OrEventTerm.OrEventTerm_1_0 returns OrBooleanTerm
	 *     AndEventTerm returns OrBooleanTerm
	 *     AndEventTerm.AndEventTerm_1_0 returns OrBooleanTerm
	 *     ConditionalTerm returns OrBooleanTerm
	 *     ConditionalTerm.ConditionalTerm_1_0 returns OrBooleanTerm
	 *     OrBooleanTerm returns OrBooleanTerm
	 *     OrBooleanTerm.OrBooleanTerm_1_0 returns OrBooleanTerm
	 *     AndBooleanTerm returns OrBooleanTerm
	 *     AndBooleanTerm.AndBooleanTerm_1_0 returns OrBooleanTerm
	 *     RelationalTerm returns OrBooleanTerm
	 *     RelationalTerm.EqualTerm_1_0_0_0 returns OrBooleanTerm
	 *     RelationalTerm.LessThanTerm_1_0_1_0 returns OrBooleanTerm
	 *     RelationalTerm.GreaterThanTerm_1_0_2_0 returns OrBooleanTerm
	 *     RelationalTerm.LessEqualTerm_1_0_3_0 returns OrBooleanTerm
	 *     RelationalTerm.GreaterEqualTerm_1_0_4_0 returns OrBooleanTerm
	 *     RelationalTerm.NotEqualTerm_1_0_5_0 returns OrBooleanTerm
	 *     AdditionTerm returns OrBooleanTerm
	 *     AdditionTerm.AddTerm_1_0_0_0 returns OrBooleanTerm
	 *     AdditionTerm.SubTerm_1_0_1_0 returns OrBooleanTerm
	 *     MultiplicationTerm returns OrBooleanTerm
	 *     MultiplicationTerm.MultTerm_1_0_0_0 returns OrBooleanTerm
	 *     MultiplicationTerm.DivTerm_1_0_1_0 returns OrBooleanTerm
	 *     PrimaryTerm returns OrBooleanTerm
	 *
	 * Constraint:
	 *     (left=OrBooleanTerm_OrBooleanTerm_1_0 right=AndBooleanTerm)
	 */
	protected void sequence_OrBooleanTerm(ISerializationContext context, OrBooleanTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__LEFT));
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrBooleanTermAccess().getOrBooleanTermLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrBooleanTermAccess().getRightAndBooleanTermParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns OrEventTerm
	 *     WhileTerm returns OrEventTerm
	 *     WhileTerm.WhileTerm_1_0 returns OrEventTerm
	 *     RepetionTerm returns OrEventTerm
	 *     RepetionTerm.RepeatTerm_1_0_0 returns OrEventTerm
	 *     RepetionTerm.RangeTerm_1_1_0 returns OrEventTerm
	 *     SequenceTerm returns OrEventTerm
	 *     SequenceTerm.FollowedByTerm_1_0 returns OrEventTerm
	 *     OrEventTerm returns OrEventTerm
	 *     OrEventTerm.OrEventTerm_1_0 returns OrEventTerm
	 *     AndEventTerm returns OrEventTerm
	 *     AndEventTerm.AndEventTerm_1_0 returns OrEventTerm
	 *     ConditionalTerm returns OrEventTerm
	 *     ConditionalTerm.ConditionalTerm_1_0 returns OrEventTerm
	 *     OrBooleanTerm returns OrEventTerm
	 *     OrBooleanTerm.OrBooleanTerm_1_0 returns OrEventTerm
	 *     AndBooleanTerm returns OrEventTerm
	 *     AndBooleanTerm.AndBooleanTerm_1_0 returns OrEventTerm
	 *     RelationalTerm returns OrEventTerm
	 *     RelationalTerm.EqualTerm_1_0_0_0 returns OrEventTerm
	 *     RelationalTerm.LessThanTerm_1_0_1_0 returns OrEventTerm
	 *     RelationalTerm.GreaterThanTerm_1_0_2_0 returns OrEventTerm
	 *     RelationalTerm.LessEqualTerm_1_0_3_0 returns OrEventTerm
	 *     RelationalTerm.GreaterEqualTerm_1_0_4_0 returns OrEventTerm
	 *     RelationalTerm.NotEqualTerm_1_0_5_0 returns OrEventTerm
	 *     AdditionTerm returns OrEventTerm
	 *     AdditionTerm.AddTerm_1_0_0_0 returns OrEventTerm
	 *     AdditionTerm.SubTerm_1_0_1_0 returns OrEventTerm
	 *     MultiplicationTerm returns OrEventTerm
	 *     MultiplicationTerm.MultTerm_1_0_0_0 returns OrEventTerm
	 *     MultiplicationTerm.DivTerm_1_0_1_0 returns OrEventTerm
	 *     PrimaryTerm returns OrEventTerm
	 *
	 * Constraint:
	 *     (left=OrEventTerm_OrEventTerm_1_0 right=AndEventTerm)
	 */
	protected void sequence_OrEventTerm(ISerializationContext context, OrEventTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__LEFT));
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrEventTermAccess().getOrEventTermLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrEventTermAccess().getRightAndEventTermParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OutputTransformation returns OutputTransformation
	 *
	 * Constraint:
	 *     term=Term
	 */
	protected void sequence_OutputTransformation(ISerializationContext context, OutputTransformation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.OUTPUT_TRANSFORMATION__TERM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.OUTPUT_TRANSFORMATION__TERM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOutputTransformationAccess().getTermTermParserRuleCall_0(), semanticObject.getTerm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypedVariable returns Parameter
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (description=ElementDescription? name=ID declaration=DataTypeDeclaration initializedTo=TypedValue?)
	 */
	protected void sequence_Parameter(ISerializationContext context, roqme.metamodel.kernel.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns PatternFunction
	 *     WhileTerm returns PatternFunction
	 *     WhileTerm.WhileTerm_1_0 returns PatternFunction
	 *     RepetionTerm returns PatternFunction
	 *     RepetionTerm.RepeatTerm_1_0_0 returns PatternFunction
	 *     RepetionTerm.RangeTerm_1_1_0 returns PatternFunction
	 *     SequenceTerm returns PatternFunction
	 *     SequenceTerm.FollowedByTerm_1_0 returns PatternFunction
	 *     OrEventTerm returns PatternFunction
	 *     OrEventTerm.OrEventTerm_1_0 returns PatternFunction
	 *     AndEventTerm returns PatternFunction
	 *     AndEventTerm.AndEventTerm_1_0 returns PatternFunction
	 *     ConditionalTerm returns PatternFunction
	 *     ConditionalTerm.ConditionalTerm_1_0 returns PatternFunction
	 *     OrBooleanTerm returns PatternFunction
	 *     OrBooleanTerm.OrBooleanTerm_1_0 returns PatternFunction
	 *     AndBooleanTerm returns PatternFunction
	 *     AndBooleanTerm.AndBooleanTerm_1_0 returns PatternFunction
	 *     RelationalTerm returns PatternFunction
	 *     RelationalTerm.EqualTerm_1_0_0_0 returns PatternFunction
	 *     RelationalTerm.LessThanTerm_1_0_1_0 returns PatternFunction
	 *     RelationalTerm.GreaterThanTerm_1_0_2_0 returns PatternFunction
	 *     RelationalTerm.LessEqualTerm_1_0_3_0 returns PatternFunction
	 *     RelationalTerm.GreaterEqualTerm_1_0_4_0 returns PatternFunction
	 *     RelationalTerm.NotEqualTerm_1_0_5_0 returns PatternFunction
	 *     AdditionTerm returns PatternFunction
	 *     AdditionTerm.AddTerm_1_0_0_0 returns PatternFunction
	 *     AdditionTerm.SubTerm_1_0_1_0 returns PatternFunction
	 *     MultiplicationTerm returns PatternFunction
	 *     MultiplicationTerm.MultTerm_1_0_0_0 returns PatternFunction
	 *     MultiplicationTerm.DivTerm_1_0_1_0 returns PatternFunction
	 *     PrimaryTerm returns PatternFunction
	 *     FunctionTerm returns PatternFunction
	 *     PatternFunction returns PatternFunction
	 *
	 * Constraint:
	 *     ((terms+=VarTerm | terms+=SelfTerm)? name=PatternFtnEnum (terms+=Term terms+=Term*)?)
	 */
	protected void sequence_PatternFunction(ISerializationContext context, PatternFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypedVariable returns PrimitiveContext
	 *     Context returns PrimitiveContext
	 *     PrimitiveContext returns PrimitiveContext
	 *
	 * Constraint:
	 *     (description=ElementDescription? name=ID declaration=DataTypeDeclaration)
	 */
	protected void sequence_PrimitiveContext(ISerializationContext context, PrimitiveContext semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypedVariable returns Property
	 *     BeliefVariable returns Property
	 *     Property returns Property
	 *
	 * Constraint:
	 *     (
	 *         description=ElementDescription? 
	 *         name=ID 
	 *         ((declaration=DataTypeDeclaration transformation=OutputTransformation) | declaration=InbuiltDeclaration) 
	 *         (reference=EDouble | survival=TimeValue)*
	 *     )
	 */
	protected void sequence_Property(ISerializationContext context, Property semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataTypeDeclaration returns ReferencedDeclaration
	 *     ReferencedDeclaration returns ReferencedDeclaration
	 *
	 * Constraint:
	 *     type=[DataTypeDefinition|ID]
	 */
	protected void sequence_ReferencedDeclaration(ISerializationContext context, ReferencedDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DatatypesPackage.Literals.REFERENCED_DECLARATION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DatatypesPackage.Literals.REFERENCED_DECLARATION__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReferencedDeclarationAccess().getTypeDataTypeDefinitionIDTerminalRuleCall_0_1(), semanticObject.eGet(DatatypesPackage.Literals.REFERENCED_DECLARATION__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns EqualTerm
	 *     WhileTerm returns EqualTerm
	 *     WhileTerm.WhileTerm_1_0 returns EqualTerm
	 *     RepetionTerm returns EqualTerm
	 *     RepetionTerm.RepeatTerm_1_0_0 returns EqualTerm
	 *     RepetionTerm.RangeTerm_1_1_0 returns EqualTerm
	 *     SequenceTerm returns EqualTerm
	 *     SequenceTerm.FollowedByTerm_1_0 returns EqualTerm
	 *     OrEventTerm returns EqualTerm
	 *     OrEventTerm.OrEventTerm_1_0 returns EqualTerm
	 *     AndEventTerm returns EqualTerm
	 *     AndEventTerm.AndEventTerm_1_0 returns EqualTerm
	 *     ConditionalTerm returns EqualTerm
	 *     ConditionalTerm.ConditionalTerm_1_0 returns EqualTerm
	 *     OrBooleanTerm returns EqualTerm
	 *     OrBooleanTerm.OrBooleanTerm_1_0 returns EqualTerm
	 *     AndBooleanTerm returns EqualTerm
	 *     AndBooleanTerm.AndBooleanTerm_1_0 returns EqualTerm
	 *     RelationalTerm returns EqualTerm
	 *     RelationalTerm.EqualTerm_1_0_0_0 returns EqualTerm
	 *     RelationalTerm.LessThanTerm_1_0_1_0 returns EqualTerm
	 *     RelationalTerm.GreaterThanTerm_1_0_2_0 returns EqualTerm
	 *     RelationalTerm.LessEqualTerm_1_0_3_0 returns EqualTerm
	 *     RelationalTerm.GreaterEqualTerm_1_0_4_0 returns EqualTerm
	 *     RelationalTerm.NotEqualTerm_1_0_5_0 returns EqualTerm
	 *     AdditionTerm returns EqualTerm
	 *     AdditionTerm.AddTerm_1_0_0_0 returns EqualTerm
	 *     AdditionTerm.SubTerm_1_0_1_0 returns EqualTerm
	 *     MultiplicationTerm returns EqualTerm
	 *     MultiplicationTerm.MultTerm_1_0_0_0 returns EqualTerm
	 *     MultiplicationTerm.DivTerm_1_0_1_0 returns EqualTerm
	 *     PrimaryTerm returns EqualTerm
	 *
	 * Constraint:
	 *     (left=RelationalTerm_EqualTerm_1_0_0_0 right=AdditionTerm)
	 */
	protected void sequence_RelationalTerm(ISerializationContext context, EqualTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__LEFT));
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationalTermAccess().getEqualTermLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getRelationalTermAccess().getRightAdditionTermParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns GreaterEqualTerm
	 *     WhileTerm returns GreaterEqualTerm
	 *     WhileTerm.WhileTerm_1_0 returns GreaterEqualTerm
	 *     RepetionTerm returns GreaterEqualTerm
	 *     RepetionTerm.RepeatTerm_1_0_0 returns GreaterEqualTerm
	 *     RepetionTerm.RangeTerm_1_1_0 returns GreaterEqualTerm
	 *     SequenceTerm returns GreaterEqualTerm
	 *     SequenceTerm.FollowedByTerm_1_0 returns GreaterEqualTerm
	 *     OrEventTerm returns GreaterEqualTerm
	 *     OrEventTerm.OrEventTerm_1_0 returns GreaterEqualTerm
	 *     AndEventTerm returns GreaterEqualTerm
	 *     AndEventTerm.AndEventTerm_1_0 returns GreaterEqualTerm
	 *     ConditionalTerm returns GreaterEqualTerm
	 *     ConditionalTerm.ConditionalTerm_1_0 returns GreaterEqualTerm
	 *     OrBooleanTerm returns GreaterEqualTerm
	 *     OrBooleanTerm.OrBooleanTerm_1_0 returns GreaterEqualTerm
	 *     AndBooleanTerm returns GreaterEqualTerm
	 *     AndBooleanTerm.AndBooleanTerm_1_0 returns GreaterEqualTerm
	 *     RelationalTerm returns GreaterEqualTerm
	 *     RelationalTerm.EqualTerm_1_0_0_0 returns GreaterEqualTerm
	 *     RelationalTerm.LessThanTerm_1_0_1_0 returns GreaterEqualTerm
	 *     RelationalTerm.GreaterThanTerm_1_0_2_0 returns GreaterEqualTerm
	 *     RelationalTerm.LessEqualTerm_1_0_3_0 returns GreaterEqualTerm
	 *     RelationalTerm.GreaterEqualTerm_1_0_4_0 returns GreaterEqualTerm
	 *     RelationalTerm.NotEqualTerm_1_0_5_0 returns GreaterEqualTerm
	 *     AdditionTerm returns GreaterEqualTerm
	 *     AdditionTerm.AddTerm_1_0_0_0 returns GreaterEqualTerm
	 *     AdditionTerm.SubTerm_1_0_1_0 returns GreaterEqualTerm
	 *     MultiplicationTerm returns GreaterEqualTerm
	 *     MultiplicationTerm.MultTerm_1_0_0_0 returns GreaterEqualTerm
	 *     MultiplicationTerm.DivTerm_1_0_1_0 returns GreaterEqualTerm
	 *     PrimaryTerm returns GreaterEqualTerm
	 *
	 * Constraint:
	 *     (left=RelationalTerm_GreaterEqualTerm_1_0_4_0 right=AdditionTerm)
	 */
	protected void sequence_RelationalTerm(ISerializationContext context, GreaterEqualTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__LEFT));
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationalTermAccess().getGreaterEqualTermLeftAction_1_0_4_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getRelationalTermAccess().getRightAdditionTermParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns GreaterThanTerm
	 *     WhileTerm returns GreaterThanTerm
	 *     WhileTerm.WhileTerm_1_0 returns GreaterThanTerm
	 *     RepetionTerm returns GreaterThanTerm
	 *     RepetionTerm.RepeatTerm_1_0_0 returns GreaterThanTerm
	 *     RepetionTerm.RangeTerm_1_1_0 returns GreaterThanTerm
	 *     SequenceTerm returns GreaterThanTerm
	 *     SequenceTerm.FollowedByTerm_1_0 returns GreaterThanTerm
	 *     OrEventTerm returns GreaterThanTerm
	 *     OrEventTerm.OrEventTerm_1_0 returns GreaterThanTerm
	 *     AndEventTerm returns GreaterThanTerm
	 *     AndEventTerm.AndEventTerm_1_0 returns GreaterThanTerm
	 *     ConditionalTerm returns GreaterThanTerm
	 *     ConditionalTerm.ConditionalTerm_1_0 returns GreaterThanTerm
	 *     OrBooleanTerm returns GreaterThanTerm
	 *     OrBooleanTerm.OrBooleanTerm_1_0 returns GreaterThanTerm
	 *     AndBooleanTerm returns GreaterThanTerm
	 *     AndBooleanTerm.AndBooleanTerm_1_0 returns GreaterThanTerm
	 *     RelationalTerm returns GreaterThanTerm
	 *     RelationalTerm.EqualTerm_1_0_0_0 returns GreaterThanTerm
	 *     RelationalTerm.LessThanTerm_1_0_1_0 returns GreaterThanTerm
	 *     RelationalTerm.GreaterThanTerm_1_0_2_0 returns GreaterThanTerm
	 *     RelationalTerm.LessEqualTerm_1_0_3_0 returns GreaterThanTerm
	 *     RelationalTerm.GreaterEqualTerm_1_0_4_0 returns GreaterThanTerm
	 *     RelationalTerm.NotEqualTerm_1_0_5_0 returns GreaterThanTerm
	 *     AdditionTerm returns GreaterThanTerm
	 *     AdditionTerm.AddTerm_1_0_0_0 returns GreaterThanTerm
	 *     AdditionTerm.SubTerm_1_0_1_0 returns GreaterThanTerm
	 *     MultiplicationTerm returns GreaterThanTerm
	 *     MultiplicationTerm.MultTerm_1_0_0_0 returns GreaterThanTerm
	 *     MultiplicationTerm.DivTerm_1_0_1_0 returns GreaterThanTerm
	 *     PrimaryTerm returns GreaterThanTerm
	 *
	 * Constraint:
	 *     (left=RelationalTerm_GreaterThanTerm_1_0_2_0 right=AdditionTerm)
	 */
	protected void sequence_RelationalTerm(ISerializationContext context, GreaterThanTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__LEFT));
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationalTermAccess().getGreaterThanTermLeftAction_1_0_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getRelationalTermAccess().getRightAdditionTermParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns LessEqualTerm
	 *     WhileTerm returns LessEqualTerm
	 *     WhileTerm.WhileTerm_1_0 returns LessEqualTerm
	 *     RepetionTerm returns LessEqualTerm
	 *     RepetionTerm.RepeatTerm_1_0_0 returns LessEqualTerm
	 *     RepetionTerm.RangeTerm_1_1_0 returns LessEqualTerm
	 *     SequenceTerm returns LessEqualTerm
	 *     SequenceTerm.FollowedByTerm_1_0 returns LessEqualTerm
	 *     OrEventTerm returns LessEqualTerm
	 *     OrEventTerm.OrEventTerm_1_0 returns LessEqualTerm
	 *     AndEventTerm returns LessEqualTerm
	 *     AndEventTerm.AndEventTerm_1_0 returns LessEqualTerm
	 *     ConditionalTerm returns LessEqualTerm
	 *     ConditionalTerm.ConditionalTerm_1_0 returns LessEqualTerm
	 *     OrBooleanTerm returns LessEqualTerm
	 *     OrBooleanTerm.OrBooleanTerm_1_0 returns LessEqualTerm
	 *     AndBooleanTerm returns LessEqualTerm
	 *     AndBooleanTerm.AndBooleanTerm_1_0 returns LessEqualTerm
	 *     RelationalTerm returns LessEqualTerm
	 *     RelationalTerm.EqualTerm_1_0_0_0 returns LessEqualTerm
	 *     RelationalTerm.LessThanTerm_1_0_1_0 returns LessEqualTerm
	 *     RelationalTerm.GreaterThanTerm_1_0_2_0 returns LessEqualTerm
	 *     RelationalTerm.LessEqualTerm_1_0_3_0 returns LessEqualTerm
	 *     RelationalTerm.GreaterEqualTerm_1_0_4_0 returns LessEqualTerm
	 *     RelationalTerm.NotEqualTerm_1_0_5_0 returns LessEqualTerm
	 *     AdditionTerm returns LessEqualTerm
	 *     AdditionTerm.AddTerm_1_0_0_0 returns LessEqualTerm
	 *     AdditionTerm.SubTerm_1_0_1_0 returns LessEqualTerm
	 *     MultiplicationTerm returns LessEqualTerm
	 *     MultiplicationTerm.MultTerm_1_0_0_0 returns LessEqualTerm
	 *     MultiplicationTerm.DivTerm_1_0_1_0 returns LessEqualTerm
	 *     PrimaryTerm returns LessEqualTerm
	 *
	 * Constraint:
	 *     (left=RelationalTerm_LessEqualTerm_1_0_3_0 right=AdditionTerm)
	 */
	protected void sequence_RelationalTerm(ISerializationContext context, LessEqualTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__LEFT));
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationalTermAccess().getLessEqualTermLeftAction_1_0_3_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getRelationalTermAccess().getRightAdditionTermParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns LessThanTerm
	 *     WhileTerm returns LessThanTerm
	 *     WhileTerm.WhileTerm_1_0 returns LessThanTerm
	 *     RepetionTerm returns LessThanTerm
	 *     RepetionTerm.RepeatTerm_1_0_0 returns LessThanTerm
	 *     RepetionTerm.RangeTerm_1_1_0 returns LessThanTerm
	 *     SequenceTerm returns LessThanTerm
	 *     SequenceTerm.FollowedByTerm_1_0 returns LessThanTerm
	 *     OrEventTerm returns LessThanTerm
	 *     OrEventTerm.OrEventTerm_1_0 returns LessThanTerm
	 *     AndEventTerm returns LessThanTerm
	 *     AndEventTerm.AndEventTerm_1_0 returns LessThanTerm
	 *     ConditionalTerm returns LessThanTerm
	 *     ConditionalTerm.ConditionalTerm_1_0 returns LessThanTerm
	 *     OrBooleanTerm returns LessThanTerm
	 *     OrBooleanTerm.OrBooleanTerm_1_0 returns LessThanTerm
	 *     AndBooleanTerm returns LessThanTerm
	 *     AndBooleanTerm.AndBooleanTerm_1_0 returns LessThanTerm
	 *     RelationalTerm returns LessThanTerm
	 *     RelationalTerm.EqualTerm_1_0_0_0 returns LessThanTerm
	 *     RelationalTerm.LessThanTerm_1_0_1_0 returns LessThanTerm
	 *     RelationalTerm.GreaterThanTerm_1_0_2_0 returns LessThanTerm
	 *     RelationalTerm.LessEqualTerm_1_0_3_0 returns LessThanTerm
	 *     RelationalTerm.GreaterEqualTerm_1_0_4_0 returns LessThanTerm
	 *     RelationalTerm.NotEqualTerm_1_0_5_0 returns LessThanTerm
	 *     AdditionTerm returns LessThanTerm
	 *     AdditionTerm.AddTerm_1_0_0_0 returns LessThanTerm
	 *     AdditionTerm.SubTerm_1_0_1_0 returns LessThanTerm
	 *     MultiplicationTerm returns LessThanTerm
	 *     MultiplicationTerm.MultTerm_1_0_0_0 returns LessThanTerm
	 *     MultiplicationTerm.DivTerm_1_0_1_0 returns LessThanTerm
	 *     PrimaryTerm returns LessThanTerm
	 *
	 * Constraint:
	 *     (left=RelationalTerm_LessThanTerm_1_0_1_0 right=AdditionTerm)
	 */
	protected void sequence_RelationalTerm(ISerializationContext context, LessThanTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__LEFT));
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationalTermAccess().getLessThanTermLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getRelationalTermAccess().getRightAdditionTermParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns NotEqualTerm
	 *     WhileTerm returns NotEqualTerm
	 *     WhileTerm.WhileTerm_1_0 returns NotEqualTerm
	 *     RepetionTerm returns NotEqualTerm
	 *     RepetionTerm.RepeatTerm_1_0_0 returns NotEqualTerm
	 *     RepetionTerm.RangeTerm_1_1_0 returns NotEqualTerm
	 *     SequenceTerm returns NotEqualTerm
	 *     SequenceTerm.FollowedByTerm_1_0 returns NotEqualTerm
	 *     OrEventTerm returns NotEqualTerm
	 *     OrEventTerm.OrEventTerm_1_0 returns NotEqualTerm
	 *     AndEventTerm returns NotEqualTerm
	 *     AndEventTerm.AndEventTerm_1_0 returns NotEqualTerm
	 *     ConditionalTerm returns NotEqualTerm
	 *     ConditionalTerm.ConditionalTerm_1_0 returns NotEqualTerm
	 *     OrBooleanTerm returns NotEqualTerm
	 *     OrBooleanTerm.OrBooleanTerm_1_0 returns NotEqualTerm
	 *     AndBooleanTerm returns NotEqualTerm
	 *     AndBooleanTerm.AndBooleanTerm_1_0 returns NotEqualTerm
	 *     RelationalTerm returns NotEqualTerm
	 *     RelationalTerm.EqualTerm_1_0_0_0 returns NotEqualTerm
	 *     RelationalTerm.LessThanTerm_1_0_1_0 returns NotEqualTerm
	 *     RelationalTerm.GreaterThanTerm_1_0_2_0 returns NotEqualTerm
	 *     RelationalTerm.LessEqualTerm_1_0_3_0 returns NotEqualTerm
	 *     RelationalTerm.GreaterEqualTerm_1_0_4_0 returns NotEqualTerm
	 *     RelationalTerm.NotEqualTerm_1_0_5_0 returns NotEqualTerm
	 *     AdditionTerm returns NotEqualTerm
	 *     AdditionTerm.AddTerm_1_0_0_0 returns NotEqualTerm
	 *     AdditionTerm.SubTerm_1_0_1_0 returns NotEqualTerm
	 *     MultiplicationTerm returns NotEqualTerm
	 *     MultiplicationTerm.MultTerm_1_0_0_0 returns NotEqualTerm
	 *     MultiplicationTerm.DivTerm_1_0_1_0 returns NotEqualTerm
	 *     PrimaryTerm returns NotEqualTerm
	 *
	 * Constraint:
	 *     (left=RelationalTerm_NotEqualTerm_1_0_5_0 right=AdditionTerm)
	 */
	protected void sequence_RelationalTerm(ISerializationContext context, NotEqualTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__LEFT));
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationalTermAccess().getNotEqualTermLeftAction_1_0_5_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getRelationalTermAccess().getRightAdditionTermParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns RangeTerm
	 *     WhileTerm returns RangeTerm
	 *     WhileTerm.WhileTerm_1_0 returns RangeTerm
	 *     RepetionTerm returns RangeTerm
	 *     RepetionTerm.RepeatTerm_1_0_0 returns RangeTerm
	 *     RepetionTerm.RangeTerm_1_1_0 returns RangeTerm
	 *     SequenceTerm returns RangeTerm
	 *     SequenceTerm.FollowedByTerm_1_0 returns RangeTerm
	 *     OrEventTerm returns RangeTerm
	 *     OrEventTerm.OrEventTerm_1_0 returns RangeTerm
	 *     AndEventTerm returns RangeTerm
	 *     AndEventTerm.AndEventTerm_1_0 returns RangeTerm
	 *     ConditionalTerm returns RangeTerm
	 *     ConditionalTerm.ConditionalTerm_1_0 returns RangeTerm
	 *     OrBooleanTerm returns RangeTerm
	 *     OrBooleanTerm.OrBooleanTerm_1_0 returns RangeTerm
	 *     AndBooleanTerm returns RangeTerm
	 *     AndBooleanTerm.AndBooleanTerm_1_0 returns RangeTerm
	 *     RelationalTerm returns RangeTerm
	 *     RelationalTerm.EqualTerm_1_0_0_0 returns RangeTerm
	 *     RelationalTerm.LessThanTerm_1_0_1_0 returns RangeTerm
	 *     RelationalTerm.GreaterThanTerm_1_0_2_0 returns RangeTerm
	 *     RelationalTerm.LessEqualTerm_1_0_3_0 returns RangeTerm
	 *     RelationalTerm.GreaterEqualTerm_1_0_4_0 returns RangeTerm
	 *     RelationalTerm.NotEqualTerm_1_0_5_0 returns RangeTerm
	 *     AdditionTerm returns RangeTerm
	 *     AdditionTerm.AddTerm_1_0_0_0 returns RangeTerm
	 *     AdditionTerm.SubTerm_1_0_1_0 returns RangeTerm
	 *     MultiplicationTerm returns RangeTerm
	 *     MultiplicationTerm.MultTerm_1_0_0_0 returns RangeTerm
	 *     MultiplicationTerm.DivTerm_1_0_1_0 returns RangeTerm
	 *     PrimaryTerm returns RangeTerm
	 *
	 * Constraint:
	 *     (term=RepetionTerm_RangeTerm_1_1_0 lowerBound=INT upperBound=INT)
	 */
	protected void sequence_RepetionTerm(ISerializationContext context, RangeTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.UNARY_TERM_OP__TERM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.UNARY_TERM_OP__TERM));
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.RANGE_TERM__LOWER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.RANGE_TERM__LOWER_BOUND));
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.RANGE_TERM__UPPER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.RANGE_TERM__UPPER_BOUND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRepetionTermAccess().getRangeTermTermAction_1_1_0(), semanticObject.getTerm());
		feeder.accept(grammarAccess.getRepetionTermAccess().getLowerBoundINTTerminalRuleCall_1_1_3_0(), semanticObject.getLowerBound());
		feeder.accept(grammarAccess.getRepetionTermAccess().getUpperBoundINTTerminalRuleCall_1_1_5_0(), semanticObject.getUpperBound());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns RepeatTerm
	 *     WhileTerm returns RepeatTerm
	 *     WhileTerm.WhileTerm_1_0 returns RepeatTerm
	 *     RepetionTerm returns RepeatTerm
	 *     RepetionTerm.RepeatTerm_1_0_0 returns RepeatTerm
	 *     RepetionTerm.RangeTerm_1_1_0 returns RepeatTerm
	 *     SequenceTerm returns RepeatTerm
	 *     SequenceTerm.FollowedByTerm_1_0 returns RepeatTerm
	 *     OrEventTerm returns RepeatTerm
	 *     OrEventTerm.OrEventTerm_1_0 returns RepeatTerm
	 *     AndEventTerm returns RepeatTerm
	 *     AndEventTerm.AndEventTerm_1_0 returns RepeatTerm
	 *     ConditionalTerm returns RepeatTerm
	 *     ConditionalTerm.ConditionalTerm_1_0 returns RepeatTerm
	 *     OrBooleanTerm returns RepeatTerm
	 *     OrBooleanTerm.OrBooleanTerm_1_0 returns RepeatTerm
	 *     AndBooleanTerm returns RepeatTerm
	 *     AndBooleanTerm.AndBooleanTerm_1_0 returns RepeatTerm
	 *     RelationalTerm returns RepeatTerm
	 *     RelationalTerm.EqualTerm_1_0_0_0 returns RepeatTerm
	 *     RelationalTerm.LessThanTerm_1_0_1_0 returns RepeatTerm
	 *     RelationalTerm.GreaterThanTerm_1_0_2_0 returns RepeatTerm
	 *     RelationalTerm.LessEqualTerm_1_0_3_0 returns RepeatTerm
	 *     RelationalTerm.GreaterEqualTerm_1_0_4_0 returns RepeatTerm
	 *     RelationalTerm.NotEqualTerm_1_0_5_0 returns RepeatTerm
	 *     AdditionTerm returns RepeatTerm
	 *     AdditionTerm.AddTerm_1_0_0_0 returns RepeatTerm
	 *     AdditionTerm.SubTerm_1_0_1_0 returns RepeatTerm
	 *     MultiplicationTerm returns RepeatTerm
	 *     MultiplicationTerm.MultTerm_1_0_0_0 returns RepeatTerm
	 *     MultiplicationTerm.DivTerm_1_0_1_0 returns RepeatTerm
	 *     PrimaryTerm returns RepeatTerm
	 *
	 * Constraint:
	 *     (term=RepetionTerm_RepeatTerm_1_0_0 nrep=INT)
	 */
	protected void sequence_RepetionTerm(ISerializationContext context, RepeatTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.UNARY_TERM_OP__TERM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.UNARY_TERM_OP__TERM));
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.REPEAT_TERM__NREP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.REPEAT_TERM__NREP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRepetionTermAccess().getRepeatTermTermAction_1_0_0(), semanticObject.getTerm());
		feeder.accept(grammarAccess.getRepetionTermAccess().getNrepINTTerminalRuleCall_1_0_3_0(), semanticObject.getNrep());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Action returns ResumeTimer
	 *     TimerAction returns ResumeTimer
	 *     ResumeTimer returns ResumeTimer
	 *
	 * Constraint:
	 *     timer=[Timer|QualifiedName]
	 */
	protected void sequence_ResumeTimer(ISerializationContext context, ResumeTimer semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KernelPackage.Literals.TIMER_ACTION__TIMER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KernelPackage.Literals.TIMER_ACTION__TIMER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getResumeTimerAccess().getTimerTimerQualifiedNameParserRuleCall_1_0_1(), semanticObject.eGet(KernelPackage.Literals.TIMER_ACTION__TIMER, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RoqmeModel returns RoqmeModel
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             ((description=ElementDescription? namespace=EString sentences+=Import+) | sentences+=Import+)? 
	 *             (dataTypes+=DataTypeDefinition | variables+=TypedVariable | sentences+=Sentence)+
	 *         ) | 
	 *         (dataTypes+=DataTypeDefinition | variables+=TypedVariable | sentences+=Sentence)+
	 *     )?
	 */
	protected void sequence_RoqmeModel(ISerializationContext context, RoqmeModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns ScheduleFunction
	 *     WhileTerm returns ScheduleFunction
	 *     WhileTerm.WhileTerm_1_0 returns ScheduleFunction
	 *     RepetionTerm returns ScheduleFunction
	 *     RepetionTerm.RepeatTerm_1_0_0 returns ScheduleFunction
	 *     RepetionTerm.RangeTerm_1_1_0 returns ScheduleFunction
	 *     SequenceTerm returns ScheduleFunction
	 *     SequenceTerm.FollowedByTerm_1_0 returns ScheduleFunction
	 *     OrEventTerm returns ScheduleFunction
	 *     OrEventTerm.OrEventTerm_1_0 returns ScheduleFunction
	 *     AndEventTerm returns ScheduleFunction
	 *     AndEventTerm.AndEventTerm_1_0 returns ScheduleFunction
	 *     ConditionalTerm returns ScheduleFunction
	 *     ConditionalTerm.ConditionalTerm_1_0 returns ScheduleFunction
	 *     OrBooleanTerm returns ScheduleFunction
	 *     OrBooleanTerm.OrBooleanTerm_1_0 returns ScheduleFunction
	 *     AndBooleanTerm returns ScheduleFunction
	 *     AndBooleanTerm.AndBooleanTerm_1_0 returns ScheduleFunction
	 *     RelationalTerm returns ScheduleFunction
	 *     RelationalTerm.EqualTerm_1_0_0_0 returns ScheduleFunction
	 *     RelationalTerm.LessThanTerm_1_0_1_0 returns ScheduleFunction
	 *     RelationalTerm.GreaterThanTerm_1_0_2_0 returns ScheduleFunction
	 *     RelationalTerm.LessEqualTerm_1_0_3_0 returns ScheduleFunction
	 *     RelationalTerm.GreaterEqualTerm_1_0_4_0 returns ScheduleFunction
	 *     RelationalTerm.NotEqualTerm_1_0_5_0 returns ScheduleFunction
	 *     AdditionTerm returns ScheduleFunction
	 *     AdditionTerm.AddTerm_1_0_0_0 returns ScheduleFunction
	 *     AdditionTerm.SubTerm_1_0_1_0 returns ScheduleFunction
	 *     MultiplicationTerm returns ScheduleFunction
	 *     MultiplicationTerm.MultTerm_1_0_0_0 returns ScheduleFunction
	 *     MultiplicationTerm.DivTerm_1_0_1_0 returns ScheduleFunction
	 *     PrimaryTerm returns ScheduleFunction
	 *     FunctionTerm returns ScheduleFunction
	 *     ScheduleFunction returns ScheduleFunction
	 *
	 * Constraint:
	 *     pattern=EString
	 */
	protected void sequence_ScheduleFunction(ISerializationContext context, ScheduleFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.SCHEDULE_FUNCTION__PATTERN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.SCHEDULE_FUNCTION__PATTERN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScheduleFunctionAccess().getPatternEStringParserRuleCall_3_0(), semanticObject.getPattern());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns SelfTerm
	 *     WhileTerm returns SelfTerm
	 *     WhileTerm.WhileTerm_1_0 returns SelfTerm
	 *     RepetionTerm returns SelfTerm
	 *     RepetionTerm.RepeatTerm_1_0_0 returns SelfTerm
	 *     RepetionTerm.RangeTerm_1_1_0 returns SelfTerm
	 *     SequenceTerm returns SelfTerm
	 *     SequenceTerm.FollowedByTerm_1_0 returns SelfTerm
	 *     OrEventTerm returns SelfTerm
	 *     OrEventTerm.OrEventTerm_1_0 returns SelfTerm
	 *     AndEventTerm returns SelfTerm
	 *     AndEventTerm.AndEventTerm_1_0 returns SelfTerm
	 *     ConditionalTerm returns SelfTerm
	 *     ConditionalTerm.ConditionalTerm_1_0 returns SelfTerm
	 *     OrBooleanTerm returns SelfTerm
	 *     OrBooleanTerm.OrBooleanTerm_1_0 returns SelfTerm
	 *     AndBooleanTerm returns SelfTerm
	 *     AndBooleanTerm.AndBooleanTerm_1_0 returns SelfTerm
	 *     RelationalTerm returns SelfTerm
	 *     RelationalTerm.EqualTerm_1_0_0_0 returns SelfTerm
	 *     RelationalTerm.LessThanTerm_1_0_1_0 returns SelfTerm
	 *     RelationalTerm.GreaterThanTerm_1_0_2_0 returns SelfTerm
	 *     RelationalTerm.LessEqualTerm_1_0_3_0 returns SelfTerm
	 *     RelationalTerm.GreaterEqualTerm_1_0_4_0 returns SelfTerm
	 *     RelationalTerm.NotEqualTerm_1_0_5_0 returns SelfTerm
	 *     AdditionTerm returns SelfTerm
	 *     AdditionTerm.AddTerm_1_0_0_0 returns SelfTerm
	 *     AdditionTerm.SubTerm_1_0_1_0 returns SelfTerm
	 *     MultiplicationTerm returns SelfTerm
	 *     MultiplicationTerm.MultTerm_1_0_0_0 returns SelfTerm
	 *     MultiplicationTerm.DivTerm_1_0_1_0 returns SelfTerm
	 *     PrimaryTerm returns SelfTerm
	 *     SelfTerm returns SelfTerm
	 *
	 * Constraint:
	 *     {SelfTerm}
	 */
	protected void sequence_SelfTerm(ISerializationContext context, SelfTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns FollowedByTerm
	 *     WhileTerm returns FollowedByTerm
	 *     WhileTerm.WhileTerm_1_0 returns FollowedByTerm
	 *     RepetionTerm returns FollowedByTerm
	 *     RepetionTerm.RepeatTerm_1_0_0 returns FollowedByTerm
	 *     RepetionTerm.RangeTerm_1_1_0 returns FollowedByTerm
	 *     SequenceTerm returns FollowedByTerm
	 *     SequenceTerm.FollowedByTerm_1_0 returns FollowedByTerm
	 *     OrEventTerm returns FollowedByTerm
	 *     OrEventTerm.OrEventTerm_1_0 returns FollowedByTerm
	 *     AndEventTerm returns FollowedByTerm
	 *     AndEventTerm.AndEventTerm_1_0 returns FollowedByTerm
	 *     ConditionalTerm returns FollowedByTerm
	 *     ConditionalTerm.ConditionalTerm_1_0 returns FollowedByTerm
	 *     OrBooleanTerm returns FollowedByTerm
	 *     OrBooleanTerm.OrBooleanTerm_1_0 returns FollowedByTerm
	 *     AndBooleanTerm returns FollowedByTerm
	 *     AndBooleanTerm.AndBooleanTerm_1_0 returns FollowedByTerm
	 *     RelationalTerm returns FollowedByTerm
	 *     RelationalTerm.EqualTerm_1_0_0_0 returns FollowedByTerm
	 *     RelationalTerm.LessThanTerm_1_0_1_0 returns FollowedByTerm
	 *     RelationalTerm.GreaterThanTerm_1_0_2_0 returns FollowedByTerm
	 *     RelationalTerm.LessEqualTerm_1_0_3_0 returns FollowedByTerm
	 *     RelationalTerm.GreaterEqualTerm_1_0_4_0 returns FollowedByTerm
	 *     RelationalTerm.NotEqualTerm_1_0_5_0 returns FollowedByTerm
	 *     AdditionTerm returns FollowedByTerm
	 *     AdditionTerm.AddTerm_1_0_0_0 returns FollowedByTerm
	 *     AdditionTerm.SubTerm_1_0_1_0 returns FollowedByTerm
	 *     MultiplicationTerm returns FollowedByTerm
	 *     MultiplicationTerm.MultTerm_1_0_0_0 returns FollowedByTerm
	 *     MultiplicationTerm.DivTerm_1_0_1_0 returns FollowedByTerm
	 *     PrimaryTerm returns FollowedByTerm
	 *
	 * Constraint:
	 *     (left=SequenceTerm_FollowedByTerm_1_0 right=ConditionalTerm)
	 */
	protected void sequence_SequenceTerm(ISerializationContext context, FollowedByTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__LEFT));
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSequenceTermAccess().getFollowedByTermLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getSequenceTermAccess().getRightConditionalTermParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Action returns SetEvidence
	 *     SetEvidence returns SetEvidence
	 *
	 * Constraint:
	 *     (influence=InfluenceEnum target=[BeliefVariable|QualifiedName] (strength=StrengthEnum | survival=TimeValue)*)
	 */
	protected void sequence_SetEvidence(ISerializationContext context, SetEvidence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns SetVariable
	 *     SetVariable returns SetVariable
	 *
	 * Constraint:
	 *     (variable=[TypedVariable|QualifiedName] expression=GeneralExpression)
	 */
	protected void sequence_SetVariable(ISerializationContext context, SetVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KernelPackage.Literals.SET_VARIABLE__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KernelPackage.Literals.SET_VARIABLE__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, KernelPackage.Literals.SET_VARIABLE__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KernelPackage.Literals.SET_VARIABLE__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetVariableAccess().getVariableTypedVariableQualifiedNameParserRuleCall_1_0_1(), semanticObject.eGet(KernelPackage.Literals.SET_VARIABLE__VARIABLE, false));
		feeder.accept(grammarAccess.getSetVariableAccess().getExpressionGeneralExpressionParserRuleCall_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Action returns StartTimer
	 *     TimerAction returns StartTimer
	 *     StartTimer returns StartTimer
	 *
	 * Constraint:
	 *     timer=[Timer|QualifiedName]
	 */
	protected void sequence_StartTimer(ISerializationContext context, StartTimer semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KernelPackage.Literals.TIMER_ACTION__TIMER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KernelPackage.Literals.TIMER_ACTION__TIMER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStartTimerAccess().getTimerTimerQualifiedNameParserRuleCall_1_0_1(), semanticObject.eGet(KernelPackage.Literals.TIMER_ACTION__TIMER, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Action returns StopTimer
	 *     TimerAction returns StopTimer
	 *     StopTimer returns StopTimer
	 *
	 * Constraint:
	 *     timer=[Timer|QualifiedName]
	 */
	protected void sequence_StopTimer(ISerializationContext context, StopTimer semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KernelPackage.Literals.TIMER_ACTION__TIMER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KernelPackage.Literals.TIMER_ACTION__TIMER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStopTimerAccess().getTimerTimerQualifiedNameParserRuleCall_1_0_1(), semanticObject.eGet(KernelPackage.Literals.TIMER_ACTION__TIMER, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TimeArray returns ArrayValue
	 *
	 * Constraint:
	 *     (values+=TimeValue values+=TimeValue*)
	 */
	protected void sequence_TimeArray(ISerializationContext context, ArrayValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnitMeasuredArray returns ArrayValue
	 *
	 * Constraint:
	 *     ((values+=UnitMeasuredValue_Impl values+=UnitMeasuredValue_Impl*) | (values+=TimeValue values+=TimeValue*))
	 */
	protected void sequence_TimeArray_UnitMeasuredArray_Impl(ISerializationContext context, ArrayValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns TimeType
	 *     TimeType returns TimeType
	 *
	 * Constraint:
	 *     cardinality=INT?
	 */
	protected void sequence_TimeType(ISerializationContext context, TimeType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypedValue returns TimeValue
	 *     SingleValue returns TimeValue
	 *     NumericValue returns TimeValue
	 *     UnitMeasuredValue returns TimeValue
	 *     TimeValue returns TimeValue
	 *
	 * Constraint:
	 *     (value=EDouble unit=TimeUnitEnum)
	 */
	protected void sequence_TimeValue(ISerializationContext context, TimeValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DatatypesPackage.Literals.NUMERIC_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DatatypesPackage.Literals.NUMERIC_VALUE__VALUE));
			if (transientValues.isValueTransient(semanticObject, DatatypesPackage.Literals.UNIT_MEASURED_VALUE__UNIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DatatypesPackage.Literals.UNIT_MEASURED_VALUE__UNIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimeValueAccess().getValueEDoubleParserRuleCall_1_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getTimeValueAccess().getUnitTimeUnitEnumParserRuleCall_2_0(), semanticObject.getUnit());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypedVariable returns Timer
	 *     Timer returns Timer
	 *
	 * Constraint:
	 *     (name=ID declaration=InbuiltDeclaration (offset=TimeValue | once?='onetime' | paused?='paused' | definition=GeneralExpression)*)
	 */
	protected void sequence_Timer(ISerializationContext context, Timer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnitMeasuredArray_Impl returns ArrayValue
	 *
	 * Constraint:
	 *     (values+=UnitMeasuredValue_Impl values+=UnitMeasuredValue_Impl*)
	 */
	protected void sequence_UnitMeasuredArray_Impl(ISerializationContext context, ArrayValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns UnitMeasuredType
	 *     UnitMeasuredType returns UnitMeasuredType
	 *
	 * Constraint:
	 *     (cardinality=INT? constraints+=NumericTypeConstraint* unit=EString constraints+=NumericTypeConstraint*)
	 */
	protected void sequence_UnitMeasuredType(ISerializationContext context, UnitMeasuredType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypedValue returns UnitMeasuredValue
	 *     SingleValue returns UnitMeasuredValue
	 *     NumericValue returns UnitMeasuredValue
	 *     UnitMeasuredValue returns UnitMeasuredValue
	 *     UnitMeasuredValue_Impl returns UnitMeasuredValue
	 *
	 * Constraint:
	 *     (value=EDouble unit=EString)
	 */
	protected void sequence_UnitMeasuredValue_Impl(ISerializationContext context, UnitMeasuredValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DatatypesPackage.Literals.NUMERIC_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DatatypesPackage.Literals.NUMERIC_VALUE__VALUE));
			if (transientValues.isValueTransient(semanticObject, DatatypesPackage.Literals.UNIT_MEASURED_VALUE__UNIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DatatypesPackage.Literals.UNIT_MEASURED_VALUE__UNIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnitMeasuredValue_ImplAccess().getValueEDoubleParserRuleCall_1_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getUnitMeasuredValue_ImplAccess().getUnitEStringParserRuleCall_2_0(), semanticObject.getUnit());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NumericTypeConstraint returns UpperBound
	 *     UpperBound returns UpperBound
	 *
	 * Constraint:
	 *     value=EDouble
	 */
	protected void sequence_UpperBound(ISerializationContext context, UpperBound semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DatatypesPackage.Literals.UPPER_BOUND__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DatatypesPackage.Literals.UPPER_BOUND__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUpperBoundAccess().getValueEDoubleParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns VarTerm
	 *     WhileTerm returns VarTerm
	 *     WhileTerm.WhileTerm_1_0 returns VarTerm
	 *     RepetionTerm returns VarTerm
	 *     RepetionTerm.RepeatTerm_1_0_0 returns VarTerm
	 *     RepetionTerm.RangeTerm_1_1_0 returns VarTerm
	 *     SequenceTerm returns VarTerm
	 *     SequenceTerm.FollowedByTerm_1_0 returns VarTerm
	 *     OrEventTerm returns VarTerm
	 *     OrEventTerm.OrEventTerm_1_0 returns VarTerm
	 *     AndEventTerm returns VarTerm
	 *     AndEventTerm.AndEventTerm_1_0 returns VarTerm
	 *     ConditionalTerm returns VarTerm
	 *     ConditionalTerm.ConditionalTerm_1_0 returns VarTerm
	 *     OrBooleanTerm returns VarTerm
	 *     OrBooleanTerm.OrBooleanTerm_1_0 returns VarTerm
	 *     AndBooleanTerm returns VarTerm
	 *     AndBooleanTerm.AndBooleanTerm_1_0 returns VarTerm
	 *     RelationalTerm returns VarTerm
	 *     RelationalTerm.EqualTerm_1_0_0_0 returns VarTerm
	 *     RelationalTerm.LessThanTerm_1_0_1_0 returns VarTerm
	 *     RelationalTerm.GreaterThanTerm_1_0_2_0 returns VarTerm
	 *     RelationalTerm.LessEqualTerm_1_0_3_0 returns VarTerm
	 *     RelationalTerm.GreaterEqualTerm_1_0_4_0 returns VarTerm
	 *     RelationalTerm.NotEqualTerm_1_0_5_0 returns VarTerm
	 *     AdditionTerm returns VarTerm
	 *     AdditionTerm.AddTerm_1_0_0_0 returns VarTerm
	 *     AdditionTerm.SubTerm_1_0_1_0 returns VarTerm
	 *     MultiplicationTerm returns VarTerm
	 *     MultiplicationTerm.MultTerm_1_0_0_0 returns VarTerm
	 *     MultiplicationTerm.DivTerm_1_0_1_0 returns VarTerm
	 *     PrimaryTerm returns VarTerm
	 *     VarTerm returns VarTerm
	 *
	 * Constraint:
	 *     variable=[TypedVariable|QualifiedName]
	 */
	protected void sequence_VarTerm(ISerializationContext context, VarTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.VAR_TERM__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.VAR_TERM__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarTermAccess().getVariableTypedVariableQualifiedNameParserRuleCall_0_1(), semanticObject.eGet(ExpressionsPackage.Literals.VAR_TERM__VARIABLE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns WhileTerm
	 *     WhileTerm returns WhileTerm
	 *     WhileTerm.WhileTerm_1_0 returns WhileTerm
	 *     RepetionTerm returns WhileTerm
	 *     RepetionTerm.RepeatTerm_1_0_0 returns WhileTerm
	 *     RepetionTerm.RangeTerm_1_1_0 returns WhileTerm
	 *     SequenceTerm returns WhileTerm
	 *     SequenceTerm.FollowedByTerm_1_0 returns WhileTerm
	 *     OrEventTerm returns WhileTerm
	 *     OrEventTerm.OrEventTerm_1_0 returns WhileTerm
	 *     AndEventTerm returns WhileTerm
	 *     AndEventTerm.AndEventTerm_1_0 returns WhileTerm
	 *     ConditionalTerm returns WhileTerm
	 *     ConditionalTerm.ConditionalTerm_1_0 returns WhileTerm
	 *     OrBooleanTerm returns WhileTerm
	 *     OrBooleanTerm.OrBooleanTerm_1_0 returns WhileTerm
	 *     AndBooleanTerm returns WhileTerm
	 *     AndBooleanTerm.AndBooleanTerm_1_0 returns WhileTerm
	 *     RelationalTerm returns WhileTerm
	 *     RelationalTerm.EqualTerm_1_0_0_0 returns WhileTerm
	 *     RelationalTerm.LessThanTerm_1_0_1_0 returns WhileTerm
	 *     RelationalTerm.GreaterThanTerm_1_0_2_0 returns WhileTerm
	 *     RelationalTerm.LessEqualTerm_1_0_3_0 returns WhileTerm
	 *     RelationalTerm.GreaterEqualTerm_1_0_4_0 returns WhileTerm
	 *     RelationalTerm.NotEqualTerm_1_0_5_0 returns WhileTerm
	 *     AdditionTerm returns WhileTerm
	 *     AdditionTerm.AddTerm_1_0_0_0 returns WhileTerm
	 *     AdditionTerm.SubTerm_1_0_1_0 returns WhileTerm
	 *     MultiplicationTerm returns WhileTerm
	 *     MultiplicationTerm.MultTerm_1_0_0_0 returns WhileTerm
	 *     MultiplicationTerm.DivTerm_1_0_1_0 returns WhileTerm
	 *     PrimaryTerm returns WhileTerm
	 *
	 * Constraint:
	 *     (left=WhileTerm_WhileTerm_1_0 right=OrBooleanTerm)
	 */
	protected void sequence_WhileTerm(ISerializationContext context, WhileTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__LEFT));
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_TERM_OP__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhileTermAccess().getWhileTermLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getWhileTermAccess().getRightOrBooleanTermParserRuleCall_1_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
}
